%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{pyqcm Documentation}
\date{Feb 16, 2022}
\release{1.0}
\author{David Sénéchal}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}

\section{What is pyqcm?}
\label{\detokenize{intro:what-is-pyqcm}}
\sphinxAtStartPar
pyqcm is a python module that interfaces with a library written in C++: \sphinxstylestrong{qcm}.
This library provide a collection of functions that help implement quantum cluster methods.
Specifically, it provides an exact diagonalization solver for small clusters on which a Hubbard\sphinxhyphen{}like model is defined and provides functions to define infinite\sphinxhyphen{}lattice models and to embed the clusters into the lattice via \sphinxstyleemphasis{Cluster Pertrubation Theory} (CPT). Methods like the \sphinxstyleemphasis{Variational Cluster Approximation} (VCA) and \sphinxstyleemphasis{Cluster Dynamical Mean Field Theory} (CDMFT) are then implemented from qcm by the pyqcm module, which is written in Python only.

\sphinxAtStartPar
This document is not a review of the above methods; the reader is referred to the appropriate review articles for that. It is strictly a user’s manual for the pyqcm module.
Some degree of understanding of the above methods is however necessary to proceed.
This document also provides insights as to the inner working of the code, and therefore consitutes also a embryonic developer’s manual.


\section{Requirements}
\label{\detokenize{intro:requirements}}
\sphinxAtStartPar
Pyqcm is written in Python and thus requires no compilation.
However, the following librairies are needed:

\sphinxAtStartPar
\sphinxstylestrong{qcm}. The source code can be cloned with the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{dsenech}\PYG{n+nd}{@bitbucket}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{dsenech}\PYG{o}{/}\PYG{n}{qcm\PYGZus{}wed}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is written in C++, and requires lapack and python3 for interfacing. It also contains the pyqcm python module.

\sphinxAtStartPar
\sphinxstylestrong{CUBA} (\sphinxurl{http://www.feynarts.de/cuba/}) is required by qcm for performing integrals in dimension \textgreater{} 2 (hence the name, for \sphinxstyleemphasis{cubature}). qcm uses version 4.0 or above. Version 2.1 is not supported. However, the CUBA library must be compiled with a modified makefile in order to use it within another shared library (the option \sphinxhyphen{}fPIC must be added. See the file \sphinxtitleref{INSTALL} included in the distribution for details).

\sphinxAtStartPar
\sphinxstylestrong{BLAS\sphinxhyphen{}LAPACK}. Needed for efficient vector and matrix operations.


\section{Compiling qcm}
\label{\detokenize{intro:compiling-qcm}}
\sphinxAtStartPar
Please consult the INSTALL files in each library’s distribution to see how to compile and install the libraries.
The shared object file qcm.so should be somewhere in the system’s Python path.


\chapter{Models and clusters}
\label{\detokenize{models:models-and-clusters}}\label{\detokenize{models::doc}}
\sphinxAtStartPar
Pyqcm can be applied to Hubbard and extended Hubbard models with one or more bands defined in 0 to 3 dimensions of space.


\section{Lattice models}
\label{\detokenize{models:lattice-models}}
\sphinxAtStartPar
The \sphinxstylestrong{qcm} library deals with lattice models.
These are defined by a Hamiltonian in dimension \(D=0,1,2\) or 3.
\(D\) is the dimension of the Brillouin zone, i.e. the number of directions in which the model is infinite and a basic unit periodically repeated. For instance, one could consider a two\sphinxhyphen{}dimensional Hubbard model (a frequent case), or maybe a two\sphinxhyphen{}dimensional model with a finite number of layers in the third dimension, for instance to study heterostructures or a slab geometry, which still constitutes a two\sphinxhyphen{}dimensional model because it is infinite in two directions only. The model is made of one\sphinxhyphen{}body terms and interaction terms and has the general form
\begin{equation*}
\begin{split}H = \sum_a h_a H_a\end{split}
\end{equation*}
\sphinxAtStartPar
where each index \(a\) represent either a one\sphinxhyphen{}body operator or an interaction term, and \(h_a\) is the (real) value of the coefficient of each term. The operator \(H_a\) is Hermitian.

\sphinxAtStartPar
The parameters \(h_a\) of the lattice model are commonly referred to as ‘lattice parameters’ in this document and in the code, to contrast them with the parameters of the cluster Hamiltonian.

\sphinxAtStartPar
In the code, the definition of an operator \(H_a\) of a one\sphinxhyphen{}body operator, the value of its coefficient \(h_a\) in the Hamiltonian and of its expectation value \(\langle H_a\rangle\) are encapsulated in the same data structure, so that the same symbol is often used to refer to all three concepts. This has to be kept in mind in this manual. When we say \sphinxstyleemphasis{the value of operator} \(H_a\), we mean the value of its coefficient \(h_a\), and we sometimes use the words \sphinxstyleemphasis{operator} and \sphinxstyleemphasis{parameter} interchangeably.

\sphinxAtStartPar
One distinguishes the following types of terms:


\subsection{One\sphinxhyphen{}body operators}
\label{\detokenize{models:one-body-operators}}\begin{equation*}
\begin{split}H_a = \sum_{\alpha\beta} t^{(a)}_{\alpha\beta} c^\dagger_\alpha c_\beta\end{split}
\end{equation*}
\sphinxAtStartPar
where each of the indices \(\alpha\) and \(\beta\) stands for a given site and spin (composite index \((i,\sigma)\)).
The hopping amplitude matrix \(t^{(a)}_{\alpha\beta}\) is Hermitian.
For a given pair of sites, labelled 1 and 2, the general form of the one\sphinxhyphen{}body term is
\begin{equation*}
\begin{split}\sum_{\alpha\beta}\sum_{i,j} c^\dagger_{i\alpha} \tau^{(a)}_{ij} \sigma^{(b)}_{\alpha\beta}  c_{j\beta}\end{split}
\end{equation*}
\sphinxAtStartPar
The use of Pauli matrices \(\sigma^b_{\alpha\beta}\) and \(\tau^a_{ij}\) makes sure that the operator is Hermitian (we suppose that \(a=0\), \(b=0\) correpsond to the identity matrix). Case \(a=1\) and \(b=0\) corresponds to an ordinary hopping term, without spin flip. In specifying the precise shape of the one\sphinxhyphen{}body operator, it will suffice to specify the matrix types \(a=0\) and \(b=0\) for the spatial and spin parts respectively.


\subsection{Anomalous operators}
\label{\detokenize{models:anomalous-operators}}\begin{equation*}
\begin{split}H_a = \sum_{\alpha\beta} \left(\Delta^{(a)}_{\alpha\beta} c_\alpha c_\beta  + \mathrm{H.c.}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where again the indices \(\alpha\) and \(\beta\) are composite indices. The pairing amplitude \(\Delta^{(a)}_{\alpha\beta}\) is antisymmetric.


\subsection{Density waves}
\label{\detokenize{models:density-waves}}\begin{quote}

\sphinxAtStartPar
If the operator is a site density wave, its expression is
\begin{equation*}
\begin{split}x\sum_\mathbf{r} A_\mathbf{r} \cos(\mathbf{Q}\cdot\mathbf{r}+\phi)\end{split}
\end{equation*}
\sphinxAtStartPar
where
\begin{equation*}
\begin{split}A_{\mathbf{r}} = n_{\mathbf{r}}, S^{z}_\mathbf{r}, S^{x}_\mathbf{r}\end{split}
\end{equation*}
\sphinxAtStartPar
If it is a bond density wave, its expression is
\begin{equation*}
\begin{split}\sum_{\mathbf{r}} \left[ x c_\mathbf{r}^\dagger c_{\mathbf{r}+\mathbf{e}} e^{i(\mathbf{Q}\cdot\mathbf{r}+\phi)} + \mathrm{H.c} \right]\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{e}\) is the link vector.

\sphinxAtStartPar
The types mean the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
‘N’ : normal, i.e., charge density wave

\item {} 
\sphinxAtStartPar
‘Z’ or ‘spin’ : spin density wave, for \(S_z\)

\item {} 
\sphinxAtStartPar
‘X’ : spin density wave, for \(S_x\)

\item {} 
\sphinxAtStartPar
‘singlet’ : a pair\sphinxhyphen{}density wave, with singlet pairing. In this case and the following, the first creation operator in the above equation is replaced by an annihilation operator.

\item {} 
\sphinxAtStartPar
‘dx’, ‘dy’ ‘dz’ : a pair density wave, with triplet pairing, with d\sphinxhyphen{}vector in the directions x, y or z.

\end{itemize}
\end{quote}


\subsection{On\sphinxhyphen{}site interaction terms}
\label{\detokenize{models:on-site-interaction-terms}}\begin{equation*}
\begin{split}H_a = \sum_{i} U^{(a)}_i n_{i\uparrow} n_{i\downarrow}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(n_{is}=c^\dagger_{is} c_{is}\) is the number operator at site \(i\) and spin projection \(s=\uparrow,\downarrow\).


\subsection{Extended interaction terms}
\label{\detokenize{models:extended-interaction-terms}}\begin{equation*}
\begin{split}H_a = \sum_{ij} V^{(a)}_{ij} n_i n_j \qquad (n_i = n_{i\uparrow}+n_{i\downarrow})\end{split}
\end{equation*}

\subsection{Hund’s coupling terms}
\label{\detokenize{models:hund-s-coupling-terms}}\begin{equation*}
\begin{split}\hat O = \sum_{i,j} J_{ij} H_{ij}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(i\) and \(j\) stand for site indices.
\begin{equation*}
\begin{split}H_{ij} = -n_{i\uparrow}n_{j\uparrow} - n_{i\downarrow}n_{j\downarrow} + c^\dagger_{i\uparrow}c_{j\uparrow}c^\dagger_{j\downarrow}c_{i\downarrow}
+ c^\dagger_{j\uparrow}c_{i\uparrow}c^\dagger_{i\downarrow}c_{j\downarrow}
+ c^\dagger_{i\uparrow}c_{j\uparrow}c^\dagger_{i\downarrow}c_{j\downarrow}
+ c^\dagger_{j\uparrow}c_{i\uparrow}c^\dagger_{j\downarrow}c_{i\downarrow}\end{split}
\end{equation*}
\sphinxAtStartPar
See, e.g., A. Liebsch and  T. A. Costi, The European Physical Journal B, Vol. 51, p. 523 (2006).
This can also be written as
\begin{equation*}
\begin{split}H_{ij} = -n_{i\uparrow}n_{j\uparrow} - n_{i\downarrow}n_{j\downarrow}
+ (c^\dagger_{i\uparrow}c_{j\uparrow}+\mathrm{H.c.})(c^\dagger_{i\downarrow}c_{j\downarrow}+ \mathrm{H.c.})\end{split}
\end{equation*}
\sphinxAtStartPar
or as
\begin{equation*}
\begin{split}H_{ij} = -c^\dagger_{i\uparrow}c^\dagger_{j\uparrow}c_{j\uparrow}c_{i\uparrow} - c^\dagger_{i\downarrow}c^\dagger_{j\downarrow}c_{j\downarrow}c_{i\downarrow}
+ c^\dagger_{i\uparrow}c^\dagger_{i\downarrow}c_{j\downarrow}c_{j\uparrow}
+ c^\dagger_{j\uparrow}c^\dagger_{j\downarrow}c_{i\downarrow}c_{i\uparrow}
- c^\dagger_{j\uparrow}c^\dagger_{i\downarrow}c_{i\uparrow}c_{j\downarrow}
- c^\dagger_{i\uparrow}c^\dagger_{j\downarrow}c_{j\uparrow}c_{i\downarrow}\end{split}
\end{equation*}

\section{Clusters}
\label{\detokenize{models:clusters}}
\sphinxAtStartPar
A cluster is a unit of the system that is solved exactly by exact diagonalization by the \sphinxstylestrong{qcm\_ED} library. There may be more than one the repeated unit (or super unit cell). The spatial correlations are exactly taken care of only within the cluster. The size of the cluster is limited by the capacity to perform exact diagonalizations. Clusters may also be attached to bath sites, which are not part of the lattice model \sphinxstyleemphasis{per se} but serve to simulate each cluster’s environment in CDMFT.
The cluster Hamiltonian \(H'\), or \sphinxstyleemphasis{reference Hamiltonian}, has the same form as the lattice Hamiltonian (except for the possible presence of a bath), but the values of its one\sphinxhyphen{}body terms, noted \(h'_a\), may differ. The interaction terms are the same on the cluster and on the lattice. The case of extended interactions requires a special treatment because of the bonds broken across cluster boundaries, which must be treated within the Hartree approximation.


\section{Lattices and superlattices}
\label{\detokenize{models:lattices-and-superlattices}}
\sphinxAtStartPar
The super unit cell (SUC) of the model is the repeated unit, made of one or more clusters.
The repetition defines a superlattice. For instance, the figure below shows how the honeycomb lattice is tiled with an 8\sphinxhyphen{}site super unit cell (shaded in blue), itself made of two 4\sphinxhyphen{}site clusters. The original Bravais basis vectors are \(\mathbf{e}_1\) and \(\mathbf{e}_2\). The superlattice vectors are \(\mathbf{E}_1\) and \(\mathbf{E}_2\). The inter\sphinxhyphen{}cluster links are indicated by dashed lines and the intra\sphinxhyphen{}cluster links by full lines.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{h8}.png}
\caption{Figure 1}\label{\detokenize{models:id1}}\end{figure}

\sphinxAtStartPar
Another example is the triangular lattice, where the supercell can be made of a two contiguous and inverted 10\sphinxhyphen{}site triangles, each of them being a cluster with the point group of the lattice, but not a repeatable pattern on the lattice. Only by adjoining two such clusters does one recover a repeatable unit.
The number of superlattice vectors defines the dimension of the lattice model.


\section{Multiband models}
\label{\detokenize{models:multiband-models}}
\sphinxAtStartPar
Multiband models are treated in \sphinxstylestrong{qcm} in a seemingly restrictive fashion, which in fact poses no restriction at all. It is assumed that each geometric site on the lattice correspond to a single orbital (with two spins). Models with more than one band must necessarily be accounted for by assigning differents sites to each band. The perfect example of this is the Hubbard model on the honeycomb (aka graphene) lattice.  The lattice is not a Bravais lattice, since it contains one vacancy for every two occupied sites on an underlying triangular lattice. But there is no obligation in \sphinxstylestrong{qcm} for the lattice to be a Bravais lattice, i.e., for every site of the Bravais lattice to be occupied by an orbital.
The reason for doing things this way is that sometimes the two bands are equivalent, like in graphene. For instance, one can then define a 6\sphinxhyphen{}site cluster centered on a vacancy (the vertices of a hexagon). See Fig. 2 below. This cluster, interesting to use because of its symmetry, is a repeatable unit of the honeycomb lattice, but does not contain three identical unit cells of graphene, and could not be used if bands were treated only on a unit\sphinxhyphen{}cell basis.
The concept of band in fact is only relevant to the lattice itself, not to the clusters, which ignore it.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{hexa6}.png}
\caption{Figure 2}\label{\detokenize{models:id2}}\end{figure}


\section{Bath sites}
\label{\detokenize{models:bath-sites}}
\sphinxAtStartPar
Each cluster treated by \sphinxstylestrong{qcm\_ED} can be associated with a bath of uncorrelated sites. This is illustrated on Fig. 3 for the four\sphinxhyphen{}site cluster of Fig. 1. From the point of view of the ED solver, the distinction between bath sites and physical sites is irrelevant. The only difference is that only physical sites have interactions. All the sites associated with a cluster are labelled consecutively, starting with the physical sites.
The bath sites do not really have a position, even though they are pictured on Fig. 3 as if they occupied neighboring sites on the lattice.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=200\sphinxpxdimen]{{h4-6b}.png}
\caption{Figure 3}\label{\detokenize{models:id3}}\end{figure}


\section{Site and orbital labels}
\label{\detokenize{models:site-and-orbital-labels}}
\sphinxAtStartPar
By convention, orbitals (or degrees of freedom) within a cluster are numbered and labelled consecutively as follows, where \(N_s\) is the number of physical sites, \(N_b\) the number of bath sites, and \(N_o=N_s+N_b\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
From 0 to \(N_s-1\), the spin up orbitals of the cluster proper.

\item {} 
\sphinxAtStartPar
From \(N_s\) to \(N_o-1\), the spin up orbitals of the bath.

\item {} 
\sphinxAtStartPar
From \(N_o\) to \(N_o+N_s-1\), the spin down orbitals of the cluster proper.

\item {} 
\sphinxAtStartPar
From \(N_o+N_s\) to \(2N_o-1\), the spin down orbitals of the bath.

\end{itemize}

\sphinxAtStartPar
The above numbering is relevant to the ED solver \sphinxstylestrong{qcm\_ED}, but not to \sphinxstylestrong{qcm}. Instead, orbitals within the super unit cell are labelled in the order of consecutive clusters and keep the same ordering as they already have within clusters, except that bath sites are excluded.
This means in particular that the spin down orbitals of the SUC are no longer grouped together; rather, it is the cluster index that is the most external index.
Explicitly, the ordering of labels is as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
From 0 to \(N_{s1}-1\), the spin up orbitals of cluster \# 1 containing \(N_{s1}\) physical sites.

\item {} 
\sphinxAtStartPar
From \(N_{s1}\) to \(2N_{s1}-1\), the spin down orbitals of cluster \# 1.

\item {} 
\sphinxAtStartPar
From \(2N_{s1}\) to \(2N_{s1}+N_{s2}-1\), the spin up orbitals of cluster \# 2 containing \(N_{s2}\) physical sites.

\item {} 
\sphinxAtStartPar
From \(2N_{s1}+N_{s2}\) to \(2N_{s1}+2N_{s2}-1\), the spin down orbitals of cluster \# 2.

\item {} 
\sphinxAtStartPar
etc.

\end{itemize}


\section{Green function indices and mixing states}
\label{\detokenize{models:green-function-indices-and-mixing-states}}
\sphinxAtStartPar
The above scheme describes the indices labeling the degrees of freedom.
A slightly different scheme labels the indices of the Green function, depending on the \sphinxstyleemphasis{mixing state}:

\sphinxAtStartPar
\sphinxstylestrong{Normal mixing}. If there are no anomalous terms nor spin\sphinxhyphen{}flip terms in the model, then the Green function (cluster or lattice) does not mix up and down spins and the Gorkov function vanishes. The cluster Green function for cluster \(i\) is a \(N_{si}\times N_{si}\) matrix, associated with the destructions operators forming an array
\begin{equation*}
\begin{split}(c_{i\uparrow}) \qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
The CPT Green function for the super unit cell (SUC) is then a \(N_s\times N_s\) matrix, where \(N_s\) is the total number of physical sites in the repeated unit:
\begin{equation*}
\begin{split}N_s = \sum_{i} N_{si}\end{split}
\end{equation*}
\sphinxAtStartPar
This mixing state is called \sphinxstyleemphasis{normal mixing}.

\sphinxAtStartPar
\sphinxstylestrong{Spin asymmetric mixing}. If the model is not spin symmetric, i.e., if the up and down spins are not equivalent, then the down part of the Green function is different, but is still a \(N_s\times N_s\) matrix. This case is called \sphinxstyleemphasis{spin asymmetric mixing}.
It entails separate computations for the up and down spin Green functions.

\sphinxAtStartPar
\sphinxstylestrong{Spin\sphinxhyphen{}flip mixing}. If there are spin\sphinxhyphen{}flip terms, but sill no anomalous terms, the cluster Green function is a \(2N_{si}\times 2N_{si}\) matrix, associated with the destructions operators forming an array
\begin{equation*}
\begin{split}(c_{i\uparrow})\oplus(c_{i\downarrow}) \qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
The CPT Green function for the SUC is then a \(2N_s\times 2N_s\) matrix, and the cluster index is the outermost index. This is called \sphinxstyleemphasis{spin\sphinxhyphen{}flip mixing}.

\sphinxAtStartPar
\sphinxstylestrong{Simple Nambu mixing}. If there are anomalous terms, but no spin\sphinxhyphen{}flip terms, the cluster Green function is a \(2N_{si}\times 2N_{si}\) matrix, associated with the destruction and creation operators forming an array
\begin{equation*}
\begin{split}(c_{i\uparrow})\oplus(c^\dagger_{i\downarrow}) \qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
The CPT Green function for the SUC is then a \(2N_s\times 2N_s\) matrix, and the cluster index is still the outermost index. This is called \sphinxstyleemphasis{simple Nambu mixing}.

\sphinxAtStartPar
\sphinxstylestrong{Full Nambu mixing}. If there are both anomalous and spin\sphinxhyphen{}flip terms, the cluster Green function is a \(4N_{si}\times 4N_{si}\) matrix, associated with the destruction and creation operators forming an array
\begin{equation*}
\begin{split}(c_{i\uparrow})\oplus(c_{i\downarrow})\oplus(c^\dagger_{i\uparrow})\oplus(c^\dagger_{i\downarrow})\qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
The CPT Green function for the SUC is then a \(4N_s\times 4N_s\) matrix, and the cluster index is still the outermost index. This is called \sphinxstyleemphasis{full Nambu mixing}.

\sphinxAtStartPar
\sphinxstylestrong{Simple spin\sphinxhyphen{}asymmetric Nambu mixing}. If there anomalous terms, no spin\sphinxhyphen{}flip terms, but up and down spins are not equivalent, the cluster Green function is a  \(2N_{si}\times 2N_{si}\) matrix, associated with the destruction and creation operators forming an array
\begin{equation*}
\begin{split}(c_{i\uparrow})\oplus(c^\dagger_{i\downarrow}) \qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
and another array
\begin{equation*}
\begin{split}(c_{i\downarrow})\oplus(c^\dagger_{i\uparrow}) \qquad i=0,\dots,N_{si}-1\end{split}
\end{equation*}
\sphinxAtStartPar
It entails separate computations for the two cases.

\sphinxAtStartPar
Different clusters may have different mixings, for instance if one of them describes a normal layer and another one a superconducting layer.
However, the lattice model will have the more general mixing of the two and the Green function of each cluster will be \sphinxstyleemphasis{upgraded} to the lattice mixing as needed, for instance by doubling it by adding a Nambu transformed part.


\chapter{Defning models}
\label{\detokenize{defining_models:defning-models}}\label{\detokenize{defining_models::doc}}
\sphinxAtStartPar
This section explains how to define models through python calls.


\section{Defining cluster models}
\label{\detokenize{defining_models:defining-cluster-models}}
\sphinxAtStartPar
Clusters are the building blocks of lattice models. One needs to define them first.
This is done through calls to \sphinxtitleref{qcm\_ED}. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqcm} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{new\PYGZus{}cluster\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2x2\PYGZus{}C2v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{new\_cluster\_model(name, Ns, Nb, perm, bath\_irrep)}} takes the following arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A name given to the cluster model

\item {} 
\sphinxAtStartPar
The number \(N_s\) of physical sites

\item {} 
\sphinxAtStartPar
The number \(N_b\)  of bath sites

\item {} 
\sphinxAtStartPar
(optional) A list of permutations of the  \(N_o=N_s+N_b\)  orbitals that define generators of the symmetries of the cluster.

\item {} 
\sphinxAtStartPar
(optional) A boolean flag that, if true, signals that bath orbitals belong to irreducible representations of the symmetry group of the cluster, instead of being part of permutations of the different orbitals of the cluster\sphinxhyphen{}bath system.

\end{enumerate}

\sphinxAtStartPar
In the above example, a four\sphinxhyphen{}site cluster is defined, without any bath sites. The positions of the sites are not relevant to \sphinxtitleref{qcm\_ED}, and so are not defined at this stage.
However, a plaquette geometry is implicit here, with the following site labels:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=100\sphinxpxdimen]{{2x2}.png}
\caption{Figure 1}\label{\detokenize{defining_models:id1}}\end{figure}

\sphinxAtStartPar
The cluster symmetries (permutations) passed to the function thus correspond to reflexions with respect to the horizontal and vertical axes, respectively.
The cluster symmetries will be used by \sphinxtitleref{qcm\_ED} to lighten the exact diagonalization task. Large clusters will take less memory, convergence of the Lanczos method will be faster, and computing the Green function at a given frequency will be more efficient.
The different permutations that constitute the generators must commute with each other. They generate an Abelian group with \(g\) elements. Such a group has an equal number \(g\) of irreducible representations, numbered from 0 to \(g-1\).


\subsection{Defining operators on the cluster}
\label{\detokenize{defining_models:defining-operators-on-the-cluster}}
\sphinxAtStartPar
Most operators in the model are best defined on the lattice and their restrition to the cluster is defined automatically, so there is no need to define them explicitly on each cluster of the super unit cell. This is not the case if one wants to use \sphinxtitleref{qcm\_ED} as a standalone ED solver without using \sphinxtitleref{qcm}.
Bath operators, on the other hand, need to be defined explicitly within the cluster model since they do not exist on the lattice model and \sphinxtitleref{qcm} only knows about their existence through a hybridization function.

\sphinxAtStartPar
The following code defines the cluster and bath operators for the cluster illustrated in the last section, which we reproduce here:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=200\sphinxpxdimen]{{h4-6b}.png}
\caption{Figure 2}\label{\detokenize{defining_models:id2}}\end{figure}

\sphinxAtStartPar
Content of the cluster definition file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqcm} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{no} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{ns} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{new\PYGZus{}cluster\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{p}{,} \PYG{n}{no}\PYG{o}{\PYGZhy{}}\PYG{n}{ns}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}


\PYG{n}{new\PYGZus{}cluster\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bt1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one\PYGZhy{}body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{]}\PYG{p}{)}

\PYG{n}{new\PYGZus{}cluster\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bt2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one\PYGZhy{}body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{]}\PYG{p}{)}

\PYG{n}{new\PYGZus{}cluster\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{be1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one\PYGZhy{}body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{]}\PYG{p}{)}

\PYG{n}{new\PYGZus{}cluster\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{be2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one\PYGZhy{}body}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{no}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the symmetry defined here is a rotation by 120 degrees. This generates the group \(C_3\), which has complex representations. \sphinxtitleref{qcm\_ED} can only deal with Abelian groups (the correct treatment of non\sphinxhyphen{}Abelian symmetries is too complex when computing Green functions for the benefits it would provide). In the above example, a better strategy when no complex operators are present would be to define only a \(C_2\) symmetry based on one of three possible reflections. This would only provide 2 symmetry operations instead of 3, but the representations would be real instead of complex, thus saving more time and memory.

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{new\_cluster\_operator(model, name, type, elements)}} takes the following arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The name of the model (the same given to \sphinxcode{\sphinxupquote{new\_model()}})

\item {} 
\sphinxAtStartPar
The name of the operator

\item {} 
\sphinxAtStartPar
The type of operator; one of ‘one\sphinxhyphen{}body’, ‘anomalous’, ‘interaction’, ‘Hund’, ‘Heisenberg’

\item {} 
\sphinxAtStartPar
An array of real matrix elements. Each element of the array is a 3\sphinxhyphen{}tuple giving the labels of the orbitals involved and the value of the matrix element itself. Note that spin\sphinxhyphen{}up and spin\sphinxhyphen{}down orbital labels are separated by the total number of orbitals on the custer, here \sphinxtitleref{no=10}.

\end{enumerate}

\sphinxAtStartPar
If a complex\sphinxhyphen{}valued operator is needed, then the function \sphinxcode{\sphinxupquote{qcm\_ED.new\_operator\_complex()}} must be used, the only difference being that the actual matrix elements are complex numbers.


\section{Defining lattice models}
\label{\detokenize{defining_models:defining-lattice-models}}

\subsection{A simple example}
\label{\detokenize{defining_models:a-simple-example}}
\sphinxAtStartPar
The following simple example illustrates how to define a Hubbard model on the square lattice in two dimensions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqcm} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{new\PYGZus{}cluster\PYGZus{}model}\PYG{p}{(}\PYG{n}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, 4, 0, [[4, 3, 2, 1]])}
\PYG{n}{add\PYGZus{}cluster}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                      \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{lattice\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2x2\PYGZus{}C2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{interaction\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{anomalous\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{anomalous\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{density\PYGZus{}wave}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is a call to \sphinxcode{\sphinxupquote{new\_cluster\_model()}} to define a \(2\times2\) plaquette with a \(C_2\) symmetry (rotation by 180 degrees). Then this cluster is added to the lattice model via the function \sphinxcode{\sphinxupquote{add\_cluster()}} which takes 3 arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The name of the cluster model (here \sphinxcode{\sphinxupquote{clus}})

\item {} 
\sphinxAtStartPar
The base position of the cluster within the super unit cell (here \sphinxcode{\sphinxupquote{{[}0,0,0{]}}})

\item {} 
\sphinxAtStartPar
An array of integer positions of the different cluster sites. This is where the geometry of the cluster appears.

\end{enumerate}

\sphinxAtStartPar
In the above example, the super unit cell contains a single cluster. Therefore \sphinxcode{\sphinxupquote{add\_cluster()}} is called only once and the lattice model can then be wrapped up by a call to \sphinxcode{\sphinxupquote{lattice\_model()}}, which takes three arguments (the last one optional):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The name of the model, for reporting purposes

\item {} 
\sphinxAtStartPar
The \(d\) vectors defining the superlattice vectors. \(d\) is the dimension of the model.

\item {} 
\sphinxAtStartPar
The \(d\) vectors defining the lattice vectors of the model. In the above example this is omitted because the default value is used: \sphinxcode{\sphinxupquote{{[}{[}1,0,0{]}, {[}0,1,0{]}{]}}}.

\end{enumerate}

\sphinxAtStartPar
Note that all vectors used in these specifications have three components (even for lower dimensional models) and have \sphinxstylestrong{integer} components. They are in fact coefficients of basis vectors generating a working Bravais lattice and are therefore integers by definition (not all vectors of this working Bravais lattice need belong to the actual Bravais lattice of the model; the case of the graphene lattice is illustrated below).

\sphinxAtStartPar
Once the geometry of the model is defined, operators can be added to the model via various functions. The Hubbard on\sphinxhyphen{}site interaction is added with a call to \sphinxcode{\sphinxupquote{interaction\_operator(\textquotesingle{}U\textquotesingle{})}}, whose sole argument in this case is the name we choose for that operator (more arguments are needed for other types of interactions, multi\sphinxhyphen{}band models, etc; see the detailed documents in the reference section on functions).

\sphinxAtStartPar
Nearest\sphinxhyphen{}neighbor hopping is defined with a call to \sphinxcode{\sphinxupquote{hopping\_operator()}}, which has three mandatory arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The name of the operator

\item {} 
\sphinxAtStartPar
The link on which the operator is defined

\item {} 
\sphinxAtStartPar
The amplitude of the operator on that link.

\end{enumerate}

\sphinxAtStartPar
Optional keyword arguments are needed for multi\sphinxhyphen{}band models, spin\sphinxhyphen{}flip operators, etc. In the above example this function is called twice with the same name but different links (along {[}1,0,0{]} and {[}0,1,0{]} respectively). The matrix elements generated by the two calls are simply added to the list associated with this operator. Similar calls are performed for the second\sphinxhyphen{}neighbor hopping \sphinxcode{\sphinxupquote{t2}} and the third\sphinxhyphen{}neighbor hopping \sphinxcode{\sphinxupquote{t3}}.

\sphinxAtStartPar
A d\sphinxhyphen{}wave pairing operator is defined via a call to \sphinxcode{\sphinxupquote{anomalous\_operator()}} , which takes the same arguments as \sphinxcode{\sphinxupquote{hopping\_operator()}}, i.e., name, link and amplitude. Note that two calls are made with the same name \sphinxcode{\sphinxupquote{D}}, one in the \(x\) direction, the other one in the \(y\) direction, with amplitudes 1 and \sphinxhyphen{}1, in accordance with the d\sphinxhyphen{}wave character of the operator.

\sphinxAtStartPar
Finally, a density wave corresponding to \((\pi,\pi)\) antiferromagnetism is added, with a call to \sphinxcode{\sphinxupquote{density\_wave()}}, which has 3 mandatory arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The name of the operator (here ‘M’)

\item {} \begin{description}
\item[{The type of density\sphinxhyphen{}wave (here ‘Z’ for a spin density wave in the \(z\) component of the spin). Other possibilities are:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
‘N’ : charge density wave

\item {} 
\sphinxAtStartPar
‘X’ : spin density wave in the \(x\) component of the spin

\item {} 
\sphinxAtStartPar
‘spin’ : same as \sphinxtitleref{Z}

\item {} 
\sphinxAtStartPar
‘singlet’ : singlet pairing

\item {} 
\sphinxAtStartPar
‘dx’ : triplet pairing in the \(x\) direction using the \(\mathbf{d}\) vector formalism.

\item {} 
\sphinxAtStartPar
‘dy’ : same, in the \(y\) direction

\item {} 
\sphinxAtStartPar
‘dz’ : same, in the \(z\) direction (this one does not require Nambu doubling)

\end{itemize}

\end{description}

\item {} 
\sphinxAtStartPar
The wavevector \(\mathbf{Q}\) of the density wave. It has real components (in multiples of \(\pi\)) and it must be commensurate with the super unit cell within some small numerical tolerance.

\end{enumerate}

\sphinxAtStartPar
Additional keyword arguments to \sphinxcode{\sphinxupquote{density\_wave()}} include the link on which the density wave is defined (for bond\sphinxhyphen{}density waves), bands involved (for multi\sphinxhyphen{}band models), additional phases and amplitudes, etc. Again, see the reference section for details.


\subsection{A more complex example}
\label{\detokenize{defining_models:a-more-complex-example}}
\sphinxAtStartPar
The following example defines a model on the graphene lattice using two cluster within the super unit cell and the graphene lattice, as illustrated below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{h8}.png}
\caption{Figure 3}\label{\detokenize{defining_models:id3}}\end{figure}

\sphinxAtStartPar
Of possible set of function calls to define the Hubbard model on this system is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cluster\PYGZus{}h4\PYGZus{}6b\PYGZus{}C3}
\PYG{k+kn}{import} \PYG{n+nn}{qcm}

\PYG{n}{add\PYGZus{}cluster}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{add\PYGZus{}cluster}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{lattice\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h4\PYGZus{}6b\PYGZus{}C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{set\PYGZus{}basis}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.866025403784438}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{interaction\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{band1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{band2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{band1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{band2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{hopping\PYGZus{}operator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{band1}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{band2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first statement, \sphinxcode{\sphinxupquote{import cluster\_h4\_6b\_C3}}, imports a cluster definition file, for instance the one associated with Fig. 2 above. Using the name \sphinxcode{\sphinxupquote{clus}} given to the cluster in that file, two copies of the clusters are added to the super unit cell. The positions associated with the two copies are different, but the cluster model is the same, which means that only one copy of the Hilbert space operators and bases necessary for the exact diagonalization will be constructed. The origin has been placed exactly between the two clusters. The positions in each cluster are defined relative to the base position of each cluster.

\sphinxAtStartPar
The integer positions are defined in terms of the basis defined by the call to \sphinxcode{\sphinxupquote{set\_basis()}}. The argument of that function is a set of real\sphinxhyphen{}valued vectors defining the basis vectors of the working Bravais lattice.
On Fig. 3, the first two of these vectors are \(\mathbf{e}_1\) and \(\mathbf{e}_2\).

\sphinxAtStartPar
The call to \sphinxcode{\sphinxupquote{lattice\_model()}} defines both the superlattice vectors \(\mathbf{E}_1\) and \(\mathbf{E}_2\) (second argument) and the basis vectors of the model’s physical Bravais lattice (third argument).
The lattice basis vectors only serve to attribute band labels to the different sites. In \sphinxtitleref{qcm}, each degree of freedom of a given spin (i.e. each orbital) must have its own site on the working Bravais lattice. The basis vectors of the physical Bravais lattice then define band labels (from 1 to \(N_\mathrm{band}\)) attributed to each site. The order in which bands are labelled depends on the order in which the sites appear. Given the above definitions and Fig. 3, the A sublattice of graphene corresponds to band 2 and the B sublattice to band 1.

\sphinxAtStartPar
Given that the model has two bands, the definition of the hopping operator \sphinxcode{\sphinxupquote{t}} must contain band information: the keywords \sphinxcode{\sphinxupquote{band1}} and \sphinxcode{\sphinxupquote{band2}} are used to specify the band numbers associated with the two sites separated by the bond vector (link) given in argument. Internally, a loop is done over all sites of the super unit cell; the bond vector is used to identify a second site; if that site exists and if the bands associated with the two sites agree with \sphinxcode{\sphinxupquote{band1}} and \sphinxcode{\sphinxupquote{band2}}, then a matrix element is added to the operator. In the above example, three calls are needed because of the three directions (bonds).

\sphinxAtStartPar
The greatest risk in such calls is to mislabel the bands. In order to check that operators were defined properly, a call to \sphinxcode{\sphinxupquote{print\_model()}} is warranted. This function takes one mandatory argument: the name of a text file in which a detailed enumeration of model properties will be printed. Additional keyword arguments control the production of asymptote files (.asy) that graphically illustrate each operator. This is a powerful way to check the validity of the model definition.


\subsection{Other examples}
\label{\detokenize{defining_models:other-examples}}
\sphinxAtStartPar
The distribution contains a folder (\sphinxtitleref{Examples}) that contains many examples of models and codes. New users are encouraged to study a few of these models and to consult the reference section for more detailed information about model building.


\chapter{Parameter sets, Hilbert space sectors and model instances}
\label{\detokenize{parameters:parameter-sets-hilbert-space-sectors-and-model-instances}}\label{\detokenize{parameters::doc}}

\section{Parameter sets}
\label{\detokenize{parameters:parameter-sets}}
\sphinxAtStartPar
Each term in the lattice Hamiltonian is associated with a parameter \(h_a\), and each cluster of the super unit cell has an equal number of parameters, for the corresponding terms of its Hamiltonian. If a bath is added to a cluster, then even more parameters are necessary to specify the cluster Hamiltonian. By default, the values of the cluster parameters are inherited from those of the lattice parameters. But their values may be different if desired.
In addition, even within the lattice or within a cluster, one may want to impose automatic constraints between parameters, such as between the Coulomb repulsion \(U\) and the chemical potential \(\mu\), or other constraints coming from accidental symmetries.
The large number of parameters and this inheritance of values needs to be managed. This is done via a \sphinxstyleemphasis{parameter set}.

\sphinxAtStartPar
On a cluster, the name of the operator will received a suffix \sphinxcode{\sphinxupquote{\_i}}, i being the cluster label (from 1 to the number of clusters \(N_\mathrm{clus}\)). Thus, from a lattice operator \sphinxcode{\sphinxupquote{t}}, an operator \sphinxcode{\sphinxupquote{t\_1}} will be constructed on cluster \#1, and an operator \sphinxcode{\sphinxupquote{t\_2}} on cluster \#2, and so on. The values of the coefficients of these operators will be designated by the same symbols. This suffix scheme will apply to all operators defined in the model and on the clusters.

\sphinxAtStartPar
The qcm library contains a single instance of a structure called \sphinxtitleref{parameter\_set} that can define equivalences between parameters beyond those imposed by default, or release the default constraints. This structure is defined in pyqcm through the function \sphinxcode{\sphinxupquote{set\_parameters(str)}}.
This may be the most important function of the library. It takes a single, long string argument, for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}parameters}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{    t = 1}
\PYG{l+s+s2}{    U = 8}
\PYG{l+s+s2}{    mu = 0.5*U}
\PYG{l+s+s2}{    M = 0}
\PYG{l+s+s2}{    M\PYGZus{}1 = 0.1}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The values of the parameters are set by the equal sign. Dependent parameters are specified by a multiple of another parameter and the multiplication (*) sign. Note that a prefactor is always required, even when it is unity. Thus, you should write \sphinxcode{\sphinxupquote{M\_2 = 1*M\_1}} and not \sphinxcode{\sphinxupquote{M\_2=M\_1}}.


\section{Hilbert space sectors}
\label{\detokenize{parameters:hilbert-space-sectors}}
\sphinxAtStartPar
For each cluster in the super unit cell, one must specify in which Hilbert space sector to look for the ground state.
Each sector is specified by a Python string indicating  which sectors of the Hilbert space must be considered in the exact diagonalization procedure. For instance, if the model conserves the number of particles and the z\sphinxhyphen{}component of the spin, the string \sphinxcode{\sphinxupquote{R0:N4:S0}} means that the ground state of the cluster must be looked for in the Hilbert space sector with N=4 electrons and S=0 spin projection. R0 means that the ground state should belong to the trivial representation (labeled 0) of the point group. The spin projection is expressed by an integer \(S = 2 S_z\). Thus, \sphinxcode{\sphinxupquote{S1}} means \(S_z=\frac12\) and \sphinxcode{\sphinxupquote{S\sphinxhyphen{}2}} means \(S_z=-1\).

\sphinxAtStartPar
The label of the irreducible representation is taken from the character table of the point group. For instance, in the important case of a \(C_{2v}\) symmetry, each irreducible representation is either even or odd with respect to horizontal and vertical reflections. The binary digits 0 and 1 are associated with even and odd symmetries, respectively.
Thus, the binary number 10 = 2 labels a representation that is odd in y and even in x, 01 = 1 labels a representation that is even in y and odd in x, 11 = 3 is odd in both directions and 00=0 is even in both directions. These possibilities are thus represented by the strings R2, R1, R3 and R0, respectively.

\sphinxAtStartPar
Hilbert space sectors are a crucial element of the use of the library and may be the source of physical errors. Performance issues dictate that not all Hilbert space sectors should be checked for the true ground state for every calculation. Some judgement must be applied as to which sector or subset of sectors contains the true ground state. For a given cluster, a subset of sectors may be provided instead of a single one, by separating the sector keywords by slashes ( / ). For instance, the string indicating that the ground state should be search in the sectors of the trivial representation, with N=4 electrons and spin projection \sphinxhyphen{}1 or 1 is \sphinxcode{\sphinxupquote{R0:N4:S\sphinxhyphen{}1/R0:N4:S1}}. Such a set of possible sectors is then specified with this call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}target\PYGZus{}sectors}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R0:N4:S\PYGZhy{}1/R0:N4:S1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the argument to that function is a list of strings, which in the above example contains a single element because the super unit cell contains a single cluster.

\sphinxAtStartPar
If spin is not conserved because of the presence of spin\sphinxhyphen{}flip terms, then the spin label must be omitted. For instance, the string “R0:N4” denotes the sector containing 4 electrons, in the trivial point group representation. An error message will be issued if the user specifies a spin sector in such cases, or inversely if the spin sector is not specified when spin is conserved.

\sphinxAtStartPar
The same is true in cases where particle number is not conserved (superconductivity): the number label must be omitted.
For instance, the string \sphinxcode{\sphinxupquote{R0:S0}} denotes the sector with zero spin, in the trivial point\sphinxhyphen{}group representation and an undetermined number of electrons.

\sphinxAtStartPar
When the target Hilbert space sector (or subset of sectors) specified in \sphinxcode{\sphinxupquote{set\_target\_sectors(...)}} does not contain the true ground state, then the Green function computed thereafter will likely have the wrong normalization and analytic properties, because “excited states” obtained from the pseudo ground state by applying creation or annihilation operators may have a lower energy than the latter.

\sphinxAtStartPar
The ED solver has a global real\sphinxhyphen{}valued parameter called \sphinxcode{\sphinxupquote{temperature}} which allows a certain mixtures of Hilbert space sectors in the density matrix of the system. This temperature must be low, as the ED solver is not a finite\sphinxhyphen{}temperature impurity solver. Only a few low\sphinxhyphen{}lying states may be computed. Within a Hilbert space sector, only the lowest\sphinxhyphen{}energy state will be found, unless the Davidson method is used and the global parameter \sphinxcode{\sphinxupquote{Davidson\_states}} is set to an integer value greater than one. A finite number of low\sphinxhyphen{}energy states will then be computed, and will contribute to the density matrix, provided their Boltzmann weight is larger than some minimum defined by the global parameter \sphinxcode{\sphinxupquote{minimum\_weight}}. The same applies to states coming from different sectors. This feature allows for a smoother transition between sectors when looping over chemical potential.


\section{Model instances}
\label{\detokenize{parameters:model-instances}}
\sphinxAtStartPar
Once a set of parameters has been recorded in the library’s parameter set, one may define an instance of the lattice model by a call to \sphinxcode{\sphinxupquote{new\_model\_instance(lab)}} , where \sphinxcode{\sphinxupquote{lab}} is a non\sphinxhyphen{}negative integer that defines a label for that instance. All computations from the qcm library are performed on a given model instance, associated with particular values of the lattice and cluster parameters. In most cases a single model instance is needed at a given time, so that the label \sphinxcode{\sphinxupquote{lab}} is 0 by default. A call to \sphinxcode{\sphinxupquote{new\_model\_instance(lab)}} will erase any previous instance of the model with the same label.

\sphinxAtStartPar
Computations on a model instance are \sphinxstylestrong{lazy}. For instance, computing the ground state of the cluster is done only when needed, for instance when asking for the ground state averages or the Green function; computing the cluster Green function representation (either Lehmann or through continued fractions) is done only when a Green\sphinxhyphen{}function related quantity is needed, etc.


\chapter{Reference: List of functions}
\label{\detokenize{functions:module-pyqcm}}\label{\detokenize{functions:reference-list-of-functions}}\label{\detokenize{functions::doc}}\index{module@\spxentry{module}!pyqcm@\spxentry{pyqcm}}\index{pyqcm@\spxentry{pyqcm}!module@\spxentry{module}}\index{CPT\_Green\_function() (in module pyqcm)@\spxentry{CPT\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.CPT_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{CPT\_Green\_function}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the CPT Green function at a given frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} complex frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single or an array of complex\sphinxhyphen{}valued matrices

\end{description}\end{quote}

\end{fulllineitems}

\index{CPT\_Green\_function\_inverse() (in module pyqcm)@\spxentry{CPT\_Green\_function\_inverse()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.CPT_Green_function_inverse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{CPT\_Green\_function\_inverse}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the inverse CPT Green function at a given frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} complex frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} array of wavevectors (ndarray(N,  :param)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single or an array of complex\sphinxhyphen{}valued matrices

\end{description}\end{quote}

\end{fulllineitems}

\index{Green\_function\_dimension() (in module pyqcm)@\spxentry{Green\_function\_dimension()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.Green_function_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{Green\_function\_dimension}}}{}{}
\sphinxAtStartPar
returns the dimension of the CPT Green function matrix
:return: int

\end{fulllineitems}

\index{Green\_function\_solve() (in module pyqcm)@\spxentry{Green\_function\_solve()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.Green_function_solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{Green\_function\_solve}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Usually, the Green function representation is computed only when needed, in a just\sphinxhyphen{}in\sphinxhyphen{}time fashion (i.e. in a lazy way).
This forces the computation of the Green function representation for the current instance (i.e. non lazy).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{Lehmann\_Green\_function() (in module pyqcm)@\spxentry{Lehmann\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.Lehmann_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{Lehmann\_Green\_function}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the Lehmann representation of the periodized Green function for a set of wavevectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3)) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band index (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of pairs \{poles, residues\}, each of poles and residues being itself a list.

\end{description}\end{quote}

\end{fulllineitems}

\index{MinimizationError@\spxentry{MinimizationError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.MinimizationError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{MinimizationError}}}
\end{fulllineitems}

\index{MissingArgError@\spxentry{MissingArgError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.MissingArgError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{MissingArgError}}}
\end{fulllineitems}

\index{OutOfBoundsError@\spxentry{OutOfBoundsError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.OutOfBoundsError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{OutOfBoundsError}}}
\end{fulllineitems}

\index{ParseError@\spxentry{ParseError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.ParseError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{ParseError}}}
\end{fulllineitems}

\index{Potthoff\_functional() (in module pyqcm)@\spxentry{Potthoff\_functional()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.Potthoff_functional}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{Potthoff\_functional}}}{\emph{\DUrole{n}{hartree}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sef.tsv\textquotesingle{}}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the Potthoff functional for a given instance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the file to append with the result

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Hartree approximation couplings (see pyqcm/hartree.py)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value of the self\sphinxhyphen{}energy functional

\end{description}\end{quote}

\end{fulllineitems}

\index{QP\_weight() (in module pyqcm)@\spxentry{QP\_weight()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.QP_weight}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{QP\_weight}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the k\sphinxhyphen{}dependent quasi\sphinxhyphen{}particle weight from the self\sphinxhyphen{}energy derived from the periodized Green function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} increment in the imaginary axis direction used to computed the derivative of the self\sphinxhyphen{}energy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band index (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single float or an array of floats, depending on the shape of k

\end{description}\end{quote}

\end{fulllineitems}

\index{TooManyIterationsError@\spxentry{TooManyIterationsError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.TooManyIterationsError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{TooManyIterationsError}}}
\end{fulllineitems}

\index{V\_matrix() (in module pyqcm)@\spxentry{V\_matrix()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.V_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{V\_matrix}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Computes the matrix \(V=G_0^{-1}-G^{c-1}_0\) at a given frequency and wavevectors, where \(G_0\) is the noninteracting Green function on the infinite lattice and \(G^c_0\) is the noninteracting Green function on the cluster.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{wavevector}}) \textendash{} wavevector (ndarray(3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single (d,d) or an array (N,d,d) of complex\sphinxhyphen{}valued matrices. d is the reduced GF dimension.

\end{description}\end{quote}

\end{fulllineitems}

\index{VarParamMismatchError@\spxentry{VarParamMismatchError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.VarParamMismatchError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{VarParamMismatchError}}}
\end{fulllineitems}

\index{WrongArgumentError@\spxentry{WrongArgumentError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.WrongArgumentError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{WrongArgumentError}}}
\end{fulllineitems}

\index{add\_cluster() (in module pyqcm)@\spxentry{add\_cluster()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.add_cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{add\_cluster}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{sites}}, \emph{\DUrole{n}{ref}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Adds a cluster to the repeated unit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} base position of cluster (array of ints)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sites}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of positions of sites (2D array of ints)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ref}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label of a previous cluster (starts at 1) to which this one is entirely equivalent (0 = no equivalence)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{anomalous\_operator() (in module pyqcm)@\spxentry{anomalous\_operator()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.anomalous_operator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{anomalous\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{link}}, \emph{\DUrole{n}{amplitude}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines an anomalous operator
\begin{quote}
\begin{quote}\begin{description}
\item[{param str name}] \leavevmode
\sphinxAtStartPar
name of operator

\item[{param {[}int{]} link}] \leavevmode
\sphinxAtStartPar
bond vector (3\sphinxhyphen{}component integer array)

\item[{param complex amplitude}] \leavevmode
\sphinxAtStartPar
pairing multiplier

\end{description}\end{quote}
\end{quote}
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
band1 (\sphinxstyleemphasis{int}) \textendash{} Band label of first index (1 by default)

\item {} 
\sphinxAtStartPar
band2 (\sphinxstyleemphasis{int}) \textendash{} Band label of second index (1 by default)

\item {} 
\sphinxAtStartPar
type (\sphinxstyleemphasis{str}) \textendash{} one of ‘singlet’ (default), ‘dz’, ‘dy’, ‘dx’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{averages() (in module pyqcm)@\spxentry{averages()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.averages}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{averages}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}averages.tsv\textquotesingle{}}}}{}
\sphinxAtStartPar
Computes the lattice averages of the operators present in the model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the file in which the information is appended

\end{itemize}

\item[{Return \{str,float\}}] \leavevmode
\sphinxAtStartPar
a dict giving the values of the averages for each parameter

\end{description}\end{quote}

\end{fulllineitems}

\index{band\_Green\_function() (in module pyqcm)@\spxentry{band\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.band_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{band\_Green\_function}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the periodized Green function at a given frequency and wavevectors, in the band basis (defined
in the noninteracting model). It only differs from the periodized Green function in multi\sphinxhyphen{}band models.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single (d,d) or an array (N,d,d) of complex\sphinxhyphen{}valued matrices. d is the reduced GF dimension.

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_Green\_function() (in module pyqcm)@\spxentry{cluster\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_Green\_function}}}{\emph{\DUrole{n}{cluster}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{blocks}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Computes the cluster Green function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (0 to the number of clusters\sphinxhyphen{}1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing =       4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (default 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{blocks}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true if returned in the basis of irreducible representations

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a complex\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_Green\_function\_average() (in module pyqcm)@\spxentry{cluster\_Green\_function\_average()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_Green_function_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_Green\_function\_average}}}{\emph{\DUrole{n}{cluster}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Computes the cluster Green function average (integral over frequencies)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (0 to the number of clusters\sphinxhyphen{}1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing =       4)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a complex\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_Green\_function\_dimension() (in module pyqcm)@\spxentry{cluster\_Green\_function\_dimension()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_Green_function_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_Green\_function\_dimension}}}{\emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the dimension of the cluster Green function matrix
:param int clus: label of the cluster
:return: int

\end{fulllineitems}

\index{cluster\_QP\_weight() (in module pyqcm)@\spxentry{cluster\_QP\_weight()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_QP_weight}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_QP\_weight}}}{\emph{\DUrole{n}{cluster}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the cluster quasi\sphinxhyphen{}particle weight from the cluster self\sphinxhyphen{}energy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} cluster label (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} increment in the imaginary axis direction used to computed the derivative of the self\sphinxhyphen{}energy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band index (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a float

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_averages() (in module pyqcm)@\spxentry{cluster\_averages()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_averages}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_averages}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Computes the average and variance of all operators of the cluster model in the cluster ground state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict str : (float, float) with the averages and variances as a function of operator name

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_hopping\_matrix() (in module pyqcm)@\spxentry{cluster\_hopping\_matrix()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_hopping_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_hopping\_matrix}}}{\emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{full}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the one\sphinxhyphen{}body matrix of cluster no i for instance ‘label’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} \textendash{} label of the cluster (0 to the number of clusters \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, returns the full hopping matrix, including bath

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a complex\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_info() (in module pyqcm)@\spxentry{cluster\_info()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_info}}}{}{}\begin{quote}\begin{description}
\item[{Return:A list of 3\sphinxhyphen{}tuples}] \leavevmode
\sphinxAtStartPar
(str, int, int): name of the cluster model, number of sites, dimension of the Green function

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_parameters() (in module pyqcm)@\spxentry{cluster\_parameters()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_parameters}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the values of the cluster parameters in a given instance, as well as the cluster model name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple:  dict\{string,float\}, str

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_self\_energy() (in module pyqcm)@\spxentry{cluster\_self\_energy()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.cluster_self_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{cluster\_self\_energy}}}{\emph{\DUrole{n}{cluster}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Computes the cluster self\sphinxhyphen{}energy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (0 to the number of clusters \sphinxhyphen{}1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing =       4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (default 0)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a complex\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{density\_wave() (in module pyqcm)@\spxentry{density\_wave()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.density_wave}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{density\_wave}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{t}}, \emph{\DUrole{n}{Q}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines a density wave
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of density\sphinxhyphen{}wave \textendash{} one of ‘Z’, ‘X’, ‘Y’, ‘N’=’cdw’, ‘singlet’, ‘dz’, ‘dy’, ‘dx’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} (\sphinxstyleliteralemphasis{\sphinxupquote{wavevector}}) \textendash{} wavevector of the density wave (in multiple of \(pi\))

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
link (\sphinxstyleemphasis{{[}int{]}}) \textendash{} bond vector, for bond density waves

\item {} 
\sphinxAtStartPar
amplitude (\sphinxstyleemphasis{complex}) \textendash{} amplitude multiplier

\item {} 
\sphinxAtStartPar
band (\sphinxstyleemphasis{int}) \textendash{} Band label (0 by default = all bands)

\item {} 
\sphinxAtStartPar
phase (\sphinxstyleemphasis{float}) \textendash{} real phase (as a multiple of \(pi\))

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{dispersion() (in module pyqcm)@\spxentry{dispersion()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.dispersion}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{dispersion}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the dispersion relation for a single or an array of wavevectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{wavevector}}) \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single (ndarray(d)) or an array (ndarray(N,d)) of real values (energies). d is the reduced GF dimension.

\end{description}\end{quote}

\end{fulllineitems}

\index{dos() (in module pyqcm)@\spxentry{dos()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.dos}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{dos}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the density of states at a given frequency.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray(d) of real values, d being the reduced GF dimension

\end{description}\end{quote}

\end{fulllineitems}

\index{epsilon() (in module pyqcm)@\spxentry{epsilon()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.epsilon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{epsilon}}}{\emph{\DUrole{n}{y}}, \emph{\DUrole{n}{pr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Performs the epsilon algorithm for accelerated convergence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} sequence to be extrapolated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pr}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, prints the resulting extrapolation

\end{itemize}

\item[{Return {[}float{]}}] \leavevmode
\sphinxAtStartPar
the extrapolated values

\end{description}\end{quote}

\end{fulllineitems}

\index{explicit\_operator() (in module pyqcm)@\spxentry{explicit\_operator()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.explicit_operator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{explicit\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{elem}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines an explicit operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elem}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxstyleliteralemphasis{\sphinxupquote{list}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxstyleliteralemphasis{\sphinxupquote{list}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of tuples. Each tuple contains three elements (in order): a list representing position, a list representing link and a complex amplitude.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
tau (\sphinxstyleemphasis{int}) \textendash{} specifies the tau Pauli matrix  (0,1,2,3)

\item {} 
\sphinxAtStartPar
sigma (\sphinxstyleemphasis{int}) \textendash{} specifies the sigma Pauli matrix  (0,1,2,3)

\item {} 
\sphinxAtStartPar
type (\sphinxstyleemphasis{str}) \textendash{} one of ‘one\sphinxhyphen{}body’ {[}default{]}, ‘singlet’, ‘dz’, ‘dy’, ‘dx’, ‘Hubbard’, ‘Hund’, ‘Heisenberg’, ‘X’, ‘Y’, ‘Z’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{ground\_state() (in module pyqcm)@\spxentry{ground\_state()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.ground_state}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{ground\_state}}}{}{}\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of pairs (float, str) of the ground state energy and sector string, for each cluster of the system

\end{description}\end{quote}

\end{fulllineitems}

\index{hopping\_operator() (in module pyqcm)@\spxentry{hopping\_operator()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.hopping_operator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{hopping\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{link}}, \emph{\DUrole{n}{amplitude}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines a hopping term or, more generally, a one\sphinxhyphen{}body operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} bond vector (3\sphinxhyphen{}component integer array)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{amplitude}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} hopping amplitude multiplier

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
band1 (\sphinxstyleemphasis{int}) \textendash{} Band label of first index (1 by default)

\item {} 
\sphinxAtStartPar
band2 (\sphinxstyleemphasis{int}) \textendash{} Band label of second index (1 by default)

\item {} 
\sphinxAtStartPar
tau (\sphinxstyleemphasis{int}) \textendash{} specifies the tau Pauli matrix  (0,1,2,3)

\item {} 
\sphinxAtStartPar
sigma (\sphinxstyleemphasis{int}) \textendash{} specifies the sigma Pauli matrix  (0,1,2,3)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{hybridization\_Lehmann() (in module pyqcm)@\spxentry{hybridization\_Lehmann()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.hybridization_Lehmann}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{hybridization\_Lehmann}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Returns the Lehmann representation of the hybridization function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar

\sphinxAtStartPar
2\sphinxhyphen{}tuple made of
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the array of M real eigenvalues, M being the number of poles in the representation

\item {} 
\sphinxAtStartPar
a rectangular (L x M) matrix (real of complex), L being the dimension of the Green function

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{hybridization\_function() (in module pyqcm)@\spxentry{hybridization\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.hybridization_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{hybridization\_function}}}{\emph{\DUrole{n}{clus}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the hybridization function for cluster ‘cluster’ and instance ‘label’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (0 to the number of clusters\sphinxhyphen{}1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a complex\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{interaction\_operator() (in module pyqcm)@\spxentry{interaction\_operator()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.interaction_operator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{interaction\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}\begin{quote}

\sphinxAtStartPar
Defines an interaction operator of type Hubbard, Hund, Heisenberg or X, Y, Z
\begin{quote}\begin{description}
\item[{param str name}] \leavevmode
\sphinxAtStartPar
name of the operator

\end{description}\end{quote}
\end{quote}
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
link (\sphinxstyleemphasis{{[}int{]}}): 3\sphinxhyphen{}component integer vector, (0,0,0) by default

\item {} 
\sphinxAtStartPar
amplitude (\sphinxstyleemphasis{float}): amplitude multiplier

\item {} 
\sphinxAtStartPar
band1 (\sphinxstyleemphasis{int}): Band label of first index (1 by default)

\item {} 
\sphinxAtStartPar
band2 (\sphinxstyleemphasis{int}): Band label of second index (1 by default)

\item {} 
\sphinxAtStartPar
type (\sphinxstyleemphasis{str}): one of ‘Hubbard’, ‘Heisenberg’, ‘Hund’, ‘X’, ‘Y’, ‘Z’

\end{itemize}
\begin{quote}\begin{description}
\item[{return}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{interactions() (in module pyqcm)@\spxentry{interactions()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.interactions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{interactions}}}{\emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the one\sphinxhyphen{}body matrix of cluster no i for instance ‘label’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} \textendash{} label of the cluster (0 to the number of clusters \sphinxhyphen{} 1)

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a real\sphinxhyphen{}valued matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{lattice\_model() (in module pyqcm)@\spxentry{lattice\_model()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.lattice_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{lattice\_model}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{superlattice}}, \emph{\DUrole{n}{lattice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
initiates the lattice model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} the name of the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{superlattice}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} array of integers of shape (d,3), d being the dimension

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lattice}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} array of integers of shape (d,3), d being the dimension. If None, will be replaced by the unit lattice.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{matrix\_elements() (in module pyqcm)@\spxentry{matrix\_elements()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.matrix_elements}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{matrix\_elements}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{op}}}{}
\sphinxAtStartPar
returns the type and matrix elements defining a Hermitian operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the operator

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple (typ, elem)

\end{description}\end{quote}

\end{fulllineitems}

\index{mixing() (in module pyqcm)@\spxentry{mixing()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.mixing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{mixing}}}{}{}
\sphinxAtStartPar
returns the mixing state of the system:
\begin{itemize}
\item {} 
\sphinxAtStartPar
0 \textendash{} normal.  GF matrix is n x n, n being the number of sites

\item {} 
\sphinxAtStartPar
1 \textendash{} anomalous. GF matrix is 2n x 2n

\item {} 
\sphinxAtStartPar
2 \textendash{} spin\sphinxhyphen{}flip.  GF matrix is 2n x 2n

\item {} 
\sphinxAtStartPar
3 \textendash{} anomalous and spin\sphinxhyphen{}flip (full Nambu doubling).  GF matrix is 4n x 4n

\item {} 
\sphinxAtStartPar
4 \textendash{} up and down spins different.  GF matrix is n x n, but computed twice, with spin\_down = false and true

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{model\_is\_closed() (in module pyqcm)@\spxentry{model\_is\_closed()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model_is_closed}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{model\_is\_closed}}}{}{}
\sphinxAtStartPar
returns True if the model can no longer be modified. False otherwise.

\end{fulllineitems}

\index{model\_size() (in module pyqcm)@\spxentry{model\_size()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model_size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{model\_size}}}{}{}\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
a 5\sphinxhyphen{}tuple:

\end{description}\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the size of the supercell

\item {} 
\sphinxAtStartPar
the number of bands

\item {} 
\sphinxAtStartPar
a tuple containing the sizes of each cluster

\item {} 
\sphinxAtStartPar
a tuple containing the sizes of each cluster’s bath

\item {} 
\sphinxAtStartPar
a tuple containing the references of each cluster (label of reference cluster, from 0 to the nunber of clusters\sphinxhyphen{}1)

\end{enumerate}

\end{fulllineitems}

\index{momentum\_profile() (in module pyqcm)@\spxentry{momentum\_profile()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.momentum_profile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{momentum\_profile}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the momentum\sphinxhyphen{}resolved average of an operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the lattice operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} array of wavevectors (ndarray(N,  :param)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
an array of values

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_cluster\_model() (in module pyqcm)@\spxentry{new\_cluster\_model()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.new_cluster_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{new\_cluster\_model}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{n\_sites}}, \emph{\DUrole{n}{n\_bath}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{generators}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bath\_irrep}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Initiates a new model (no operators yet)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name to be given to the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_sites}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of cluster sites

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_bath}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of bath sites

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{generators}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} symmetry generators (2D array of ints)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bath\_irrep}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} True if bath orbitals belong to irreducible representations of the symmetry group

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_cluster\_model\_instance() (in module pyqcm)@\spxentry{new\_cluster\_model\_instance()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.new_cluster_model_instance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{new\_cluster\_model\_instance}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{values}}, \emph{\DUrole{n}{sec}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Initiates a new instance of the cluster model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{float\}}}) \textendash{} values of the operators

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sec}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} target Hilbert space sectors

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of model\_instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_cluster\_operator() (in module pyqcm)@\spxentry{new\_cluster\_operator()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.new_cluster_operator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{new\_cluster\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{op\_name}}, \emph{\DUrole{n}{op\_type}}, \emph{\DUrole{n}{elem}}}{}
\sphinxAtStartPar
creates a new operator from its matrix elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model to which the operator will belong

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of operator (‘one\sphinxhyphen{}body’, ‘anomalous’, ‘interaction’, ‘Hund’, ‘Heisenberg’, ‘X’, ‘Y’, ‘Z’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elem}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} array of matrix elements (list of tuples)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_cluster\_operator\_complex() (in module pyqcm)@\spxentry{new\_cluster\_operator\_complex()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.new_cluster_operator_complex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{new\_cluster\_operator\_complex}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{op\_name}}, \emph{\DUrole{n}{op\_type}}, \emph{\DUrole{n}{elem}}}{}
\sphinxAtStartPar
creates a new operator from its complex\sphinxhyphen{}valued matrix elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model to which the operator will belong

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of operator (‘one\sphinxhyphen{}body’, ‘anomalous’, ‘interaction’, ‘Hund’, ‘Heisenberg’, ‘X’, ‘Y’, ‘Z’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elem}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} array of matrix elements (list of tuples)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_model\_instance() (in module pyqcm)@\spxentry{new\_model\_instance()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.new_model_instance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{new\_model\_instance}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{record}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Creates a new instance of the lattice model, with values associated to terms of the Hamiltonian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{record}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, keeps a str\sphinxhyphen{}valued record of the instance in memory, containing all the data necessary to read the instance back without solving.

\end{itemize}

\item[{Return (class model\_instance)}] \leavevmode
\sphinxAtStartPar
an instance of the class \sphinxtitleref{model\_instance}

\end{description}\end{quote}

\end{fulllineitems}

\index{parameter\_set() (in module pyqcm)@\spxentry{parameter\_set()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.parameter_set}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{parameter\_set}}}{\emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}all\textquotesingle{}}}}{}
\sphinxAtStartPar
returns the content of the parameter set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} governs the action of the function

\item[{Returns}] \leavevmode
\sphinxAtStartPar
depends on opt

\end{description}\end{quote}

\sphinxAtStartPar
if opt = ‘all’, all parameters as a dictionary \{str,(float, str, float)\}. The three components are
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
\sphinxAtStartPar
the value of the parameter,

\item {} 
\sphinxAtStartPar
the name of its overlord (or None),

\item {} 
\sphinxAtStartPar
the multiplier by which its value is obtained from that of the overlord.

\end{enumerate}

\sphinxAtStartPar
if opt = ‘independent’, returns only the independent parameters, as a dictionary \{str,float\}
if opt = ‘report’, returns a string with parameter values and dependencies.

\end{fulllineitems}

\index{parameter\_string() (in module pyqcm)@\spxentry{parameter\_string()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.parameter_string}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{parameter\_string}}}{\emph{\DUrole{n}{lattice}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{CR}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Returns a string with the model parameters. 
:param boolean lattice : if True, only indicates the independent lattice parameters.
:param boolean CR : if True, put each parameter on a line.

\end{fulllineitems}

\index{parameters() (in module pyqcm)@\spxentry{parameters()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{parameters}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the values of the parameters in a given instance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict \{string,float\}

\end{description}\end{quote}

\end{fulllineitems}

\index{params\_from\_file() (in module pyqcm)@\spxentry{params\_from\_file()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.params_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{params\_from\_file}}}{\emph{\DUrole{n}{out\_file}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
reads an output file for parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out\_file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of output file from which parameters are read

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} line number of data in output file (excluding titles).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict of (parameter, value)

\end{description}\end{quote}

\end{fulllineitems}

\index{periodized\_Green\_function() (in module pyqcm)@\spxentry{periodized\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.periodized_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{periodized\_Green\_function}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the periodized Green function at a given frequency and wavevectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single (d,d) or an array (N,d,d) of complex\sphinxhyphen{}valued matrices. d is the reduced GF dimension.

\end{description}\end{quote}

\end{fulllineitems}

\index{periodized\_Green\_function\_element() (in module pyqcm)@\spxentry{periodized\_Green\_function\_element()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.periodized_Green_function_element}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{periodized\_Green\_function\_element}}}{\emph{\DUrole{n}{r}}, \emph{\DUrole{n}{c}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the element (r,c) of the periodized Green function at a given frequency and wavevectors (starts at 0)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} a row index (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} a column index (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a vector of complex numbers

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_averages() (in module pyqcm)@\spxentry{print\_averages()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_averages}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_averages}}}{\emph{\DUrole{n}{ave}}}{}
\sphinxAtStartPar
Prints the averages nicely on the screen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ave}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} the dictionary produced by qcm.averages()

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_cluster\_averages() (in module pyqcm)@\spxentry{print\_cluster\_averages()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_cluster_averages}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_cluster\_averages}}}{\emph{\DUrole{n}{ave}}}{}
\sphinxAtStartPar
Prints the averages nicely on the screen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ave}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} the dictionary produced by qcm.averages()

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_graph() (in module pyqcm)@\spxentry{print\_graph()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_graph}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{sites}}}{}
\sphinxAtStartPar
prints a graphiz (dot) program for the cluster
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sites}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of positions of sites (2D array of ints)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_model() (in module pyqcm)@\spxentry{print\_model()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_model}}}{\emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
Prints a description of the model into a file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_options() (in module pyqcm)@\spxentry{print\_options()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_options}}}{\emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Prints the list of global options and parameters on the screen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} 0 \sphinxhyphen{}\textgreater{} prints to screen. 1 \sphinxhyphen{}\textgreater{} prints to latex. 2 \sphinxhyphen{}\textgreater{} prints to RST

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_parameters() (in module pyqcm)@\spxentry{print\_parameters()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_parameters}}}{\emph{\DUrole{n}{P}}}{}
\sphinxAtStartPar
Prints the parameters nicely on the screen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} the dictionary of parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_wavefunction() (in module pyqcm)@\spxentry{print\_wavefunction()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.print_wavefunction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{print\_wavefunction}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
prints the ground state wavefunction(s) on the screen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{projected\_Green\_function() (in module pyqcm)@\spxentry{projected\_Green\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.projected_Green_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{projected\_Green\_function}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the projected Green function at a given frequency, as used in CDMFT.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the projected Green function matrix (d x d), d being the dimension of the CPT Green function.

\end{description}\end{quote}

\end{fulllineitems}

\index{properties() (in module pyqcm)@\spxentry{properties()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.properties}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{properties}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Returns two strings of properties of a model instance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a pair of strings (the description line and the data line).

\end{description}\end{quote}

\end{fulllineitems}

\index{qmatrix() (in module pyqcm)@\spxentry{qmatrix()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.qmatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{qmatrix}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Returns the Lehmann representation of the Green function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
2\sphinxhyphen{}tuple made of
1. the array of M real eigenvalues, M being the number of poles in the representation
2. a rectangular (L x M) matrix (real of complex), L being the dimension of the Green function

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_cluster\_model\_instance() (in module pyqcm)@\spxentry{read\_cluster\_model\_instance()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.read_cluster_model_instance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{read\_cluster\_model\_instance}}}{\emph{\DUrole{n}{S}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
reads the solution from a string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} long string containing the solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of model\_instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_from\_file() (in module pyqcm)@\spxentry{read\_from\_file()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.read_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{read\_from\_file}}}{\emph{\DUrole{n}{out\_file}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
reads an output file for parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out\_file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of output file from which parameters are read

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} line number of data in output file (excluding titles)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
string to be added to an eventual input file

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_from\_file\_legacy() (in module pyqcm)@\spxentry{read\_from\_file\_legacy()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.read_from_file_legacy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{read\_from\_file\_legacy}}}{\emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
reads model parameters from a text file, for legacy results
:param str filename: name of the input text file

\end{fulllineitems}

\index{read\_model() (in module pyqcm)@\spxentry{read\_model()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.read_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{read\_model}}}{\emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
Reads the definition of the model from a file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} \textendash{} name of the file, the same as that of the model, i.e., without the ‘.model’ suffix.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{reduced\_Green\_function\_dimension() (in module pyqcm)@\spxentry{reduced\_Green\_function\_dimension()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.reduced_Green_function_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{reduced\_Green\_function\_dimension}}}{}{}
\sphinxAtStartPar
returns the dimension of the reduced Green function, i.e. a simple multiple of the
number of bands n, depending on the mixing state: n, 2n or 4n, and the number of bands

\end{fulllineitems}

\index{self\_energy() (in module pyqcm)@\spxentry{self\_energy()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.self_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{self\_energy}}}{\emph{\DUrole{n}{z}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the self\sphinxhyphen{}energy associated with the periodized Green function at a given frequency and wavevectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single (d,d) or an array (N,d,d) of complex\sphinxhyphen{}valued matrices. d is the reduced GF dimension.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_basis() (in module pyqcm)@\spxentry{set\_basis()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_basis}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_basis}}}{\emph{\DUrole{n}{B}}}{}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} the basis (a (D x 3) real matrix)

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_global\_parameter() (in module pyqcm)@\spxentry{set\_global\_parameter()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_global_parameter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_global\_parameter}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
sets the value of a global parameter. 
If the global parameter is Boolean, then value is True by default and should not be specified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the global option

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} value of that option (None, int, float or str)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameter() (in module pyqcm)@\spxentry{set\_parameter()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_parameter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_parameter}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}}, \emph{\DUrole{n}{pr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
sets the value of a parameter within a parameter\_set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} its value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameters() (in module pyqcm)@\spxentry{set\_parameters()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_parameters}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{dump}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Defines a new set of parameters, including dependencies
\begin{quote}
\begin{quote}\begin{description}
\item[{param tuple/str params}] \leavevmode
\sphinxAtStartPar
the values/dependence of the parameters (array of 2\sphinxhyphen{} or 3\sphinxhyphen{}tuples), or string containing syntax

\item[{param boolean dump}] \leavevmode
\sphinxAtStartPar
if True, sets the global str parameter\_set\_str tothe value

\end{description}\end{quote}
\end{quote}
\begin{quote}\begin{description}
\item[{Return {[}tuple{]}}] \leavevmode
\sphinxAtStartPar
list of tuples of the form (str, float) or (str, float, str). The first form gives the parameter name and its value. The second gives the parameter name, a multiplier and the name of the reference parameter. See the documentation on the hierarchy of parameters.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_params\_from\_file() (in module pyqcm)@\spxentry{set\_params\_from\_file()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_params_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_params\_from\_file}}}{\emph{\DUrole{n}{out\_file}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
reads an output file for parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out\_file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of output file from which parameters are read

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} line number of data in output file (excluding titles)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_target\_sectors() (in module pyqcm)@\spxentry{set\_target\_sectors()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.set_target_sectors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{set\_target\_sectors}}}{\emph{\DUrole{n}{sec}}}{}
\sphinxAtStartPar
Define the Hilbert space sectors in which to look for the ground state
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sec}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} the target sectors

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{site\_and\_bond\_profile() (in module pyqcm)@\spxentry{site\_and\_bond\_profile()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.site_and_bond_profile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{site\_and\_bond\_profile}}}{}{}
\sphinxAtStartPar
Computes the site and bond profiles in all clusters of the repeated unit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A pair of ndarrays

\end{description}\end{quote}

\sphinxAtStartPar
site profile \textendash{} the components are 
x y z n Sx Sy Sz psi.real psi.imag

\sphinxAtStartPar
bond profile \textendash{} the components are  
x1 y1 z1 x2 y2 z2 b0 bx by bz d0.real dx.real dy.real dz.real d0.imag dx.imag dy.imag dz.imag

\end{fulllineitems}

\index{spatial\_dimension() (in module pyqcm)@\spxentry{spatial\_dimension()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.spatial_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{spatial\_dimension}}}{}{}
\sphinxAtStartPar
returns the spatial dimension (0, 1, 2, 3) of the model

\end{fulllineitems}

\index{spectral\_average() (in module pyqcm)@\spxentry{spectral\_average()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.spectral_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{spectral\_average}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
returns the contribution of a frequency to the average of an operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} name of the operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} complex frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{spin\_spectral\_function() (in module pyqcm)@\spxentry{spin\_spectral\_function()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.spin_spectral_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{spin\_spectral\_function}}}{\emph{\DUrole{n}{freq}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the k\sphinxhyphen{}dependent spin\sphinxhyphen{}resolved spectral function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} \textendash{} complex freqency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band index (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
depending on the shape of k, a nd.array(3) of nd.array(N,3)

\end{description}\end{quote}

\end{fulllineitems}

\index{susceptibility() (in module pyqcm)@\spxentry{susceptibility()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.susceptibility}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{susceptibility}}}{\emph{\DUrole{n}{op\_name}}, \emph{\DUrole{n}{freqs}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the dynamic susceptibility of an operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freqs}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} array of complex frequencies

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of cluster model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
array of complex susceptibilities

\end{description}\end{quote}

\end{fulllineitems}

\index{susceptibility\_poles() (in module pyqcm)@\spxentry{susceptibility\_poles()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.susceptibility_poles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{susceptibility\_poles}}}{\emph{\DUrole{n}{op\_name}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the dynamic susceptibility of an operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of cluster model instance

\end{itemize}

\item[{Returns {[}(float,float){]}}] \leavevmode
\sphinxAtStartPar
array of 2\sphinxhyphen{}tuple (pole, residue)

\end{description}\end{quote}

\end{fulllineitems}

\index{switch\_cluster\_model() (in module pyqcm)@\spxentry{switch\_cluster\_model()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.switch_cluster_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{switch\_cluster\_model}}}{\emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
switches cluster model to ‘name’. Hack used in DCA.

\end{fulllineitems}

\index{tk() (in module pyqcm)@\spxentry{tk()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.tk}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{tk}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
computes the k\sphinxhyphen{}dependent one\sphinxhyphen{}body matrix of the lattice model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} single wavevector (ndarray(3) or array of wavevectors (ndarray(N,3))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a single or an array of complex\sphinxhyphen{}valued matrices

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_bath() (in module pyqcm)@\spxentry{update\_bath()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.update_bath}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{update\_bath}}}{\emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
updates the model parameters without creating a new instance or reseting the instance specified
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{variational\_parameters() (in module pyqcm)@\spxentry{variational\_parameters()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.variational_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{variational\_parameters}}}{}{}\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of the names of the variational parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{wavevector\_grid() (in module pyqcm)@\spxentry{wavevector\_grid()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.wavevector_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{wavevector\_grid}}}{\emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{orig}\DUrole{o}{=}\DUrole{default_value}{{[}\sphinxhyphen{} 1.0, \sphinxhyphen{} 1.0{]}}}, \emph{\DUrole{n}{side}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}z\textquotesingle{}}}}{}
\sphinxAtStartPar
Produces a set of wavevectors for a MDC
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on the side

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{orig}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} origin (in multiples of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{side}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} length of the side (in multiples of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiples of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray of wavevectors (n*n x 3)

\end{description}\end{quote}

\end{fulllineitems}

\index{wavevector\_path() (in module pyqcm)@\spxentry{wavevector\_path()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.wavevector_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{wavevector\_path}}}{\emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{32}}, \emph{\DUrole{n}{shape}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}triangle\textquotesingle{}}}}{}
\sphinxAtStartPar
Builds a wavevector path and associated tick marks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors per segment

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} the geometry of the path, one of: line, halfline, triangle, graphene, graphene2, diagonal, cubic, cubic2, tetragonal, tetragonal2  OR a tuple with two wavevectors for a straight path between the two

\end{itemize}

\item[{Returns tuple}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
a ndarray of wavevectors 2) a list of tick positions 3) a list of tick strings

\end{enumerate}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_cluster\_instance\_to\_file() (in module pyqcm)@\spxentry{write\_cluster\_instance\_to\_file()}\spxextra{in module pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.write_cluster_instance_to_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{write\_cluster\_instance\_to\_file}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Writes the solved cluster model instance to a text file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster model instance

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}



\section{List of classes}
\label{\detokenize{functions:list-of-classes}}\index{model (class in pyqcm)@\spxentry{model}\spxextra{class in pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{model}}}\index{\_\_init\_\_() (pyqcm.model method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{model\_instance (class in pyqcm)@\spxentry{model\_instance}\spxextra{class in pyqcm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model_instance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.}}\sphinxbfcode{\sphinxupquote{model\_instance}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{label}}}{}\index{\_\_init\_\_() (pyqcm.model\_instance method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.model\_instance method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{functions:pyqcm.model_instance.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{label}}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Spectral properties}
\label{\detokenize{spectral:spectral-properties}}\label{\detokenize{spectral::doc}}
\sphinxAtStartPar
This submodule provides functions that plot spectral properties (mostly the spectral function) as a function of frequency and/or wavevector.


\section{List of functions}
\label{\detokenize{spectral:module-pyqcm.spectral}}\label{\detokenize{spectral:list-of-functions}}\index{module@\spxentry{module}!pyqcm.spectral@\spxentry{pyqcm.spectral}}\index{pyqcm.spectral@\spxentry{pyqcm.spectral}!module@\spxentry{module}}\index{DoS() (in module pyqcm.spectral)@\spxentry{DoS()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.DoS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{DoS}}}{\emph{\DUrole{n}{w}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{sum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{labels}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{colors}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the density of states (DoS) as a function of frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} array of real frequencies or complex frequencies, or simply single maximum frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} Lorentzian broadening, if w is real

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sum}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, the sum of the DoS of all bands is plotted in addition to each band individually

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, prints computation progress

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{labels}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} labels of the different curves

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{colors}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} colors of the different curves

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{Fermi\_surface() (in module pyqcm.spectral)@\spxentry{Fermi\_surface()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.Fermi_surface}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{Fermi\_surface}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the Fermi surface of the non\sphinxhyphen{}interacting model (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if None, plots all the bands. Otherwise just plots the FS for that band (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of \(\pi\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{G\_dispersion() (in module pyqcm.spectral)@\spxentry{G\_dispersion()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.G_dispersion}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{G\_dispersion}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{period}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}G\textquotesingle{}}}, \emph{\DUrole{n}{contour}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{inv}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{datafile}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the eigenvalues of the inverse Green function at zero frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if 0, plots all the bands. Otherwise just shows the plot for that band (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{period}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} periodization scheme (‘G’, ‘M’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{contour}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True for a contour plot; otherwise a 3D plot.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True if the inverse eigenvalues (inverse energies) are plotted instead

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datafile}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if different from None, just writes the data in a file and does not plot

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} energy range (from \sphinxhyphen{}max to max)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of \(pi\))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{Luttinger\_surface() (in module pyqcm.spectral)@\spxentry{Luttinger\_surface()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.Luttinger_surface}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{Luttinger\_surface}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the Luttinger surface (zeros of the Green function) in the Brillouin zone (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band number (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} for 3D models, value of the component of k perpendicular to the plane

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} for 3D models, plane of the plot (‘z’=’xy’, ‘y’=’xz’, ‘x=’yz’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{cluster\_spectral\_function() (in module pyqcm.spectral)@\spxentry{cluster\_spectral\_function()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.cluster_spectral_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{cluster\_spectral\_function}}}{\emph{\DUrole{n}{wmax}\DUrole{o}{=}\DUrole{default_value}{6}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{full}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{self}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{blocks}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the spectral function of the cluster in the site basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wmax}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} the frequency range is from \sphinxhyphen{}wmax to wmax

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} Lorentzian broadening

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster within the super unit cell (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} vertical offset in the plot between the curves associated to successive wavevectors

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots off\sphinxhyphen{}diagonal components as well

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the self\sphinxhyphen{}energy instead of the spectral function

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the spin down part, if different

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{blocks}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, gives the GF in the symmetry basis (block diagonal)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the array of frequencies, the spectral weight

\end{description}\end{quote}

\end{fulllineitems}

\index{dispersion() (in module pyqcm.spectral)@\spxentry{dispersion()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.dispersion}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{dispersion}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{contour}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{datafile}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the dispersion relation in the Brillouin zone (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if None, sums all the bands. Otherwise just shows the weight for that band (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{contour}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True if a contour plot is produced instead of a 3D plot.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datafile}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if given, name of the data file (no extension please) in which the data is printed, for plotting with an external program. Does not plot. Will produce one file per band, with the .tsv extension.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{gap() (in module pyqcm.spectral)@\spxentry{gap()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.gap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{gap}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}}{}
\sphinxAtStartPar
Computes the spectral gap for a series of wavevectors

\sphinxAtStartPar
:param k : set of wavevectors
:param int band : band number (starts at 1)
:param float threshold : weight below which a Lehmann contribution is deemed zero
returns: an array of gap values

\end{fulllineitems}

\index{hybridization\_function() (in module pyqcm.spectral)@\spxentry{hybridization\_function()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.hybridization_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{hybridization\_function}}}{\emph{\DUrole{n}{wmax}\DUrole{o}{=}\DUrole{default_value}{6}}, \emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{realpart}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
This function plots the imaginary part of the hybridization function Gamma as a function of frequency.
Only the diagonal elements are plotted, but for all clusters if there is more than one.
The arguments have the same meaning as in \sphinxtitleref{plot\_spectrum}, except ‘realpart’ which, if True, plots
the real part instead of the imaginary part.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wmax}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} the frequency range is {[}\sphinxhyphen{}wmax, wmax{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} cluster index (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{realpart}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, the real part of the Green function is shown, not the imaginary part

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{mdc() (in module pyqcm.spectral)@\spxentry{mdc()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.mdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{mdc}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}GF\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{freq}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{band\_basis}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the spectral weight at zero frequency in the Brillouin zone (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} Lorentzian broadening

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if None, sums all the bands. Otherwise just shows the weight for that band (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} true is the spin down sector is to be computed (applies if mixing = 4)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The quantity to plot. ‘GF’ = Green function, ‘self’ = self\sphinxhyphen{}energy, ‘Z’ = quasi\sphinxhyphen{}particle weigt

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} frequency at which the spectral function is computed (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} maximum value of the plotting range (if None, maximum of the data)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band\_basis}} \textendash{} uses the band basis instead of the orbital basis (for multiband models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} size of the plot, in multiple of the default (2 pi on the side)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the contour plot object

\end{description}\end{quote}

\end{fulllineitems}

\index{mdc\_anomalous() (in module pyqcm.spectral)@\spxentry{mdc\_anomalous()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.mdc_anomalous}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{mdc\_anomalous}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{w}\DUrole{o}{=}\DUrole{default_value}{0.1j}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{bands}\DUrole{o}{=}\DUrole{default_value}{(1, 1)}}, \emph{\DUrole{n}{self}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{im\_part}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the anomalous Green function or self\sphinxhyphen{}energy (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#complex}{\sphinxstyleliteralemphasis{\sphinxupquote{complex}}}) \textendash{} complex frequency at which the Green function is computed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bands}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} shows the weight for (b1,b2) (starts at 1), or numpy array of spin\sphinxhyphen{}Nambu projection

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the anomalous self\sphinxhyphen{}energy instead of the spectral function

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{im\_part}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the imaginary part instead of the real part

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} for 3D models, value of the component of k perpendicular to the plane

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} for 3D models, plane of the plot (‘z’=’xy’, ‘y’=’xz’, ‘x=’yz’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{momentum\_profile() (in module pyqcm.spectral)@\spxentry{momentum\_profile()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.momentum_profile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{momentum\_profile}}}{\emph{\DUrole{n}{op}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{50}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the momentum\sphinxhyphen{}resolved average of operator op in the Brillouin zone (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{op}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the lattice operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{segment\_dispersion() (in module pyqcm.spectral)@\spxentry{segment\_dispersion()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.segment_dispersion}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{segment\_dispersion}}}{\emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}triangle\textquotesingle{}}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the dispersion relation in the Brillouin zone along a wavevector path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} wavevector path, as used by the function wavevector\_path()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{spectral\_function() (in module pyqcm.spectral)@\spxentry{spectral\_function()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.spectral_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{spectral\_function}}}{\emph{\DUrole{n}{wmax}\DUrole{o}{=}\DUrole{default_value}{6.0}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}triangle\textquotesingle{}}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{32}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}A\textquotesingle{}}}, \emph{\DUrole{n}{Nambu\_redress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{inverse\_path}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the spectral function \(A(\mathbf{k},\omega)\) along a wavevector path in the Brillouin zone.
This version plots the spin\sphinxhyphen{}down part with the correct sign of the frequency in the Nambu formalism.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wmax}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} the frequency range is from \sphinxhyphen{}wmax to wmax if w is a float. Otherwise wmax is a tuple and the range is (wmax{[}0{]}, wmax{[}1{]})

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} Lorentzian broadening

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} a keyword that is passed to pyqcm.wavevector\_grid() to produce a set of wavevectors along a path, or a tuple

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the number of wavevectors along each segment of the path (passed to pyqcm.wavevector\_grid())

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the instance of the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if not None, only plots the spectral function associated with this orbital number (starts at 1). If None, sums over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} vertical offset in the plot between the curves associated to successive wavevectors

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} ‘A’ : spectral function, ‘self’ : self\sphinxhyphen{}energy, ‘Sx’ : spin (x component), ‘Sy’ : spin (y component)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Nambu\_redress}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, evaluates the Nambu component at the opposite frequency

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inverse\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, inverts the path (k \textendash{}\textgreater{} \sphinxhyphen{}k)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} optional title for the plot. If None, a string with the model parameters will be used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{spectral\_function\_Lehmann() (in module pyqcm.spectral)@\spxentry{spectral\_function\_Lehmann()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.spectral_function_Lehmann}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{spectral\_function\_Lehmann}}}{\emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}triangle\textquotesingle{}}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{32}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{lims}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots a Lehmann representation of the spectral function along a wavevector path in the Brillouin zone
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} if a string, keyword passed to \sphinxtitleref{pyqcm.wavevector\_path()} to produce a set of wavevectors; else, explicit list of wavevectors (N x 3 numpy array).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the number of wavevectors along each segment of the path (passed to pyqcm.wavevector\_path())

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the instance of the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} only plots the spectral function associated with this orbital number (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} vertical offset in the plot between the curves associated to successive wavevectors

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lims}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} limits of the plot in frequency (2\sphinxhyphen{}tuple)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{spin\_mdc() (in module pyqcm.spectral)@\spxentry{spin\_mdc()}\spxextra{in module pyqcm.spectral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral:pyqcm.spectral.spin_mdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.spectral.}}\sphinxbfcode{\sphinxupquote{spin\_mdc}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{quadrant}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}plain\textquotesingle{}}}, \emph{\DUrole{n}{freq}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{band\_basis}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Plots the spin spectral weight at zero frequency in the Brillouin zone (2D)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on each side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} Lorentzian broadening

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} if None, sums all the bands. Otherwise just shows the weight for that band (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quadrant}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, plots the first quadrant of a square Brillouin zone only

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The quantity to plot. ‘spin’ = spin texture, ‘spins’ = spin texture (saturated), ‘sz’ = z\sphinxhyphen{}component, ‘spinp’ = modulus of xy\sphinxhyphen{}component

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} frequency at which the spectral function is computed (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} maximum value of the plotting range (if None, maximum of the data)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (in multiple of pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band\_basis}} \textendash{} uses the band basis instead of the orbital basis (for multiband models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The contour plot object

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Topology : Berry curvature computations}
\label{\detokenize{berry:topology-berry-curvature-computations}}\label{\detokenize{berry::doc}}
\sphinxAtStartPar
This submodule provides functions that compute topological quantities (Berry curvature, Chern number, etc.)

\phantomsection\label{\detokenize{berry:module-pyqcm.berry}}\index{module@\spxentry{module}!pyqcm.berry@\spxentry{pyqcm.berry}}\index{pyqcm.berry@\spxentry{pyqcm.berry}!module@\spxentry{module}}\index{Berry\_curvature() (in module pyqcm.berry)@\spxentry{Berry\_curvature()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.Berry_curvature}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{Berry\_curvature}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{period}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}G\textquotesingle{}}}, \emph{\DUrole{n}{range}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{subdivide}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Draws a 2D density plot of the Berry curvature as a function of wavevector, on a square grid going from \sphinxhyphen{}pi to pi in each direction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on the side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} imaginary part of the frequency at zero, i.e., w = eta*1j

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{period}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of periodization used (e.g. ‘G’, ‘M’, ‘None’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxstyleliteralemphasis{\sphinxupquote{list}}}) \textendash{} range of plot {[}originX, originY, side{]}, in multiples of pi

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subdivide}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} True if plaquette subdivision is used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} momentum component in the third direction (x pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the file to save the plot. If None, shows the plot on screen.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the contourplot object of matplotlib

\end{description}\end{quote}

\end{fulllineitems}

\index{Berry\_field\_map() (in module pyqcm.berry)@\spxentry{Berry\_field\_map()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.Berry_field_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{Berry\_field\_map}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{nsides}\DUrole{o}{=}\DUrole{default_value}{4}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}z\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Creates a plot of the Berry flux as a function of wavevector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevector grid points on each side

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nsides}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of sides of the polygon used to compute the circulation of the Berry field.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} offset in wavevector in the direction perpendicular to the plane (x pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the file to save the plot. If None, shows the plot on screen.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the contourplot object of matplotlib, the quiver object of matplotlib

\end{description}\end{quote}

\end{fulllineitems}

\index{Berry\_flux() (in module pyqcm.berry)@\spxentry{Berry\_flux()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.Berry_flux}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{Berry\_flux}}}{\emph{\DUrole{n}{k0}}, \emph{\DUrole{n}{R}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xy\textquotesingle{}}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Computes the integral of the Berry connexion along a closed circle
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k0}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} center of the circle

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{R}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} radius of the circle

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on the circle

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} label of the model instance (0 by default)

\end{itemize}

\item[{Returns float}] \leavevmode
\sphinxAtStartPar
the flux

\end{description}\end{quote}

\end{fulllineitems}

\index{Berry\_flux\_map() (in module pyqcm.berry)@\spxentry{Berry\_flux\_map()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.Berry_flux_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{Berry\_flux\_map}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}z\textquotesingle{}}}, \emph{\DUrole{n}{dir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}z\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{npoints}\DUrole{o}{=}\DUrole{default_value}{4}}, \emph{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Creates a plot of the Berry flux as a function of wavevector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevector grid points on each side

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dir}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} direction of flux, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} offset in wavevector in the direction perpendicular to the plane (x pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{npoints}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} nombre de points sur chaque boucle

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the file to save the plot. If None, shows the plot on screen.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the contourplot object of matplotlib

\end{description}\end{quote}

\end{fulllineitems}

\index{Chern\_number() (in module pyqcm.berry)@\spxentry{Chern\_number()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.Chern_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{Chern\_number}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{eta}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{period}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}G\textquotesingle{}}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{{[}0.0, 0.0, 0.0{]}}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{subdivide}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Computes the Chern number by summing the Berry curvature over wavevectors on a square grid going from (0,0) to (pi,pi)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevectors on the side of the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} imaginary part of the frequency at zero, i.e., w = eta*1j

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{period}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of periodization used (e.g. ‘G’, ‘M’, ‘None’)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{wavevector}}) \textendash{} wavevector offset of the computation grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all occupied bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subdivide}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} recursivity flag (wavevector grid subdivision)

\end{itemize}

\item[{Returns float}] \leavevmode
\sphinxAtStartPar
The Chern number

\end{description}\end{quote}

\end{fulllineitems}

\index{monopole() (in module pyqcm.berry)@\spxentry{monopole()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.monopole}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{monopole}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{n}{a}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{subdivide}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
computes the topological charge of a node in a Weyl semi\sphinxhyphen{}metal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} wavevector, position of the node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} half\sphinxhyphen{}side of the cube surrounding the node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of divisions along the side of the cube

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} band to compute the charge of (if 0, sums over all bands)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{subdivide}} (\sphinxstyleliteralemphasis{\sphinxupquote{booleean}}) \textendash{} True if subdivision is allowed (False by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} label of the model instance (0 by default)

\end{itemize}

\item[{Return float}] \leavevmode
\sphinxAtStartPar
the monopole charge

\end{description}\end{quote}

\end{fulllineitems}

\index{monopole\_map() (in module pyqcm.berry)@\spxentry{monopole\_map()}\spxextra{in module pyqcm.berry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{berry:pyqcm.berry.monopole_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.berry.}}\sphinxbfcode{\sphinxupquote{monopole\_map}}}{\emph{\DUrole{n}{nk}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{band}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plane}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}z\textquotesingle{}}}, \emph{\DUrole{n}{k\_perp}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Creates a plot of the monopole density (divergence of B) as a function of wavevector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nk}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of wavevector grid points on each side

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plane}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} momentum plane, ‘xy’=’z’, ‘yz’=’x’=’zy’ or ‘xz’=’zx’=’y’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k\_perp}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} offset in wavevector in the direction perpendicular to the plane (x pi)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the model instance (0 by default)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{band}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the band to use in the computation (1 to number of bands). 0 (default) means a sum over all bands.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the file to save the plot. If None, shows the plot on screen.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the contourplot object of matplotlib

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Cluster Dynamical Mean Field Theory}
\label{\detokenize{cdmft:cluster-dynamical-mean-field-theory}}\label{\detokenize{cdmft::doc}}
\sphinxAtStartPar
This submodule provides functions that perform the CDMFT algorithm.


\section{List of functions}
\label{\detokenize{cdmft:module-pyqcm.cdmft}}\label{\detokenize{cdmft:list-of-functions}}\index{module@\spxentry{module}!pyqcm.cdmft@\spxentry{pyqcm.cdmft}}\index{pyqcm.cdmft@\spxentry{pyqcm.cdmft}!module@\spxentry{module}}\index{cdmft() (in module pyqcm.cdmft)@\spxentry{cdmft()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.cdmft}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{cdmft}}}{\emph{\DUrole{n}{varia}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{beta}\DUrole{o}{=}\DUrole{default_value}{50}}, \emph{\DUrole{n}{wc}\DUrole{o}{=}\DUrole{default_value}{2.0}}, \emph{\DUrole{n}{maxiter}\DUrole{o}{=}\DUrole{default_value}{32}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{accur\_hybrid}\DUrole{o}{=}\DUrole{default_value}{0.0001}}, \emph{\DUrole{n}{accur\_dist}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}10}}, \emph{\DUrole{n}{displaymin}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}CG\textquotesingle{}}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cdmft.tsv\textquotesingle{}}}, \emph{\DUrole{n}{skip\_averages}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{eps\_algo}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{initial\_step}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{hartree}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{check\_sectors}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{grid\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sharp\textquotesingle{}}}, \emph{\DUrole{n}{counterterms}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{SEF}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{observables}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Performs the CDMFT procedure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variational parameters 
OR tuple of two lists : bath energies and bath hybridizations
OR function that returns dicts of bath energies and bath hybridizations given numeric arrays

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} inverse fictitious temperature (for the frequency grid)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wc}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} cutoff frequency (for the frequency grid)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxiter}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} maximum number of CDMFT iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} the procedure converges if parameters do not change by more than accur

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur\_hybrid}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} the procedure converges on the hybridization function with this accuracy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur\_dist}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} convergence criterion when minimizing the distance function.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{displaymin}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} displays the minimum distance function when minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} method to use, as used in scipy.optimize.minimize()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the file where the solution is written

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{skip\_averages}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, does NOT compute the lattice averages of the converged solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eps\_algo}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of elements in the epsilon algorithm convergence accelerator = 2*eps\_algo + 1 (0 = no acceleration)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_step}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} initial step in the minimization routine

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} mean\sphinxhyphen{}field hartree couplings to incorportate in the convergence procedure

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{check\_sectors}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} the ground state is checked against the ground states of the sectors contained in target\_sectors

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of frequency grid along the imaginary axis : ‘sharp’, ‘ifreq’, ‘self’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counterterms}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of counterterms names (cluster operators that should strive to have zero average)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{SEF}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, computes the Potthoff functional at the end

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{observable}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} list of observables used to assess convergence

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{cdmft\_distance\_debug() (in module pyqcm.cdmft)@\spxentry{cdmft\_distance\_debug()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.cdmft_distance_debug}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{cdmft\_distance\_debug}}}{\emph{\DUrole{n}{varia}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{vset}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{beta}\DUrole{o}{=}\DUrole{default_value}{50}}, \emph{\DUrole{n}{wc}\DUrole{o}{=}\DUrole{default_value}{2.0}}, \emph{\DUrole{n}{grid\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sharp\textquotesingle{}}}, \emph{\DUrole{n}{counterterms}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Debugs the CDMFT distance function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variational parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vset}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} sets of bath parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} inverse fictitious temperature (for the frequency grid)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wc}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} cutoff frequency (for the frequency grid)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} type of frequency grid along the imaginary axis : ‘sharp’, ‘ifreq’, ‘self’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counterterms}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of counterterms names (cluster operators that should strive to have zero average)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{SEF}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, computes the Potthoff functional at the end

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{observable}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} list of observables used to assess convergence

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{cdmft\_forcing() (in module pyqcm.cdmft)@\spxentry{cdmft\_forcing()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.cdmft_forcing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{cdmft\_forcing}}}{\emph{\DUrole{n}{field\_name}}, \emph{\DUrole{n}{seq}}, \emph{\DUrole{n}{beta\_seq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
performs a sequence of CDMFT runs with the external field ‘field\_name’ takes the successive values in ‘seq’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{field\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the forcing field

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{seq}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} sequence of values to be taken by the forcing field

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beta\_seq}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} an optional sequence of fictitious inverse temperatures (same length as seq)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} named parameters passed to the CDMFT function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{cdmft\_variational\_sequence() (in module pyqcm.cdmft)@\spxentry{cdmft\_variational\_sequence()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.cdmft_variational_sequence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{cdmft\_variational\_sequence}}}{\emph{\DUrole{n}{basic\_params}}, \emph{\DUrole{n}{varia\_seq}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
performs a sequence of CDMFT runs with an increasing variational set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{basic\_params}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} specifies non variational parameters, in the format used by set\_parameters()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia\_seq}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} a sequence of strings specifying additional variational parameters and their initial values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} named parameters passed to the CDMFT function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{forcing\_sequence() (in module pyqcm.cdmft)@\spxentry{forcing\_sequence()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.forcing_sequence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{forcing\_sequence}}}{\emph{\DUrole{n}{f1}}, \emph{\DUrole{n}{f2}}, \emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{6}}}{}
\sphinxAtStartPar
generates logarithmic sequences of fields and temperatures, for use with cdmft\_forcing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} high value of the field

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} low value of the field

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} low value of the inverse temperature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} high value of the inverse temperature

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of values in the sequence

\end{itemize}

\item[{Return ({[}float{]},{[}float{]})}] \leavevmode
\sphinxAtStartPar
lists of field and beta values

\end{description}\end{quote}

\end{fulllineitems}

\index{moving\_std() (in module pyqcm.cdmft)@\spxentry{moving\_std()}\spxextra{in module pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.moving_std}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{moving\_std}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{min}}}{}
\sphinxAtStartPar
finds the subsequence with the smallest standard deviation, with minimum size min
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} sequence

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} minimum length of subsequence

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{List of classes}
\label{\detokenize{cdmft:list-of-classes}}\index{general\_bath (class in pyqcm.cdmft)@\spxentry{general\_bath}\spxextra{class in pyqcm.cdmft}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.cdmft.}}\sphinxbfcode{\sphinxupquote{general\_bath}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{ns}}, \emph{\DUrole{n}{nb}}, \emph{\DUrole{n}{spin\_dependent}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{spin\_flip}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{singlet}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{triplet}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{complex}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sites}\DUrole{o}{=}\DUrole{default_value}{None}}}{}\index{\_\_init\_\_() (pyqcm.cdmft.general\_bath method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{ns}}, \emph{\DUrole{n}{nb}}, \emph{\DUrole{n}{spin\_dependent}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{spin\_flip}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{singlet}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{triplet}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{complex}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sites}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Defines a general bath (constructor)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster\sphinxhyphen{}bath model to be defined

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ns}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of sites in the cluster

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nb}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of bath orbitals in the cluster

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_dependent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, the parameters are spin dependent

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_flip}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, spin\sphinxhyphen{}flip hybridizations are present

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{singlet}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, defines anomalous singlet hybridizations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{triplet}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, defines anomalous triplet hybridizations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{complex}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, defines imaginary parts as well, when appropriate

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sites}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} 2\sphinxhyphen{}level list of sites to couple to the bath orbitals (labels from 1 to ns)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{starting\_values() (pyqcm.cdmft.general\_bath method)@\spxentry{starting\_values()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.starting_values}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{starting\_values}}}{\emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{e}\DUrole{o}{=}\DUrole{default_value}{(0.5, 1.5)}}, \emph{\DUrole{n}{hyb}\DUrole{o}{=}\DUrole{default_value}{(0.5, 0.2)}}, \emph{\DUrole{n}{shyb}\DUrole{o}{=}\DUrole{default_value}{(0.1, 0.05)}}, \emph{\DUrole{n}{pr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
returns an initialization string for the bath parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} cluster label (starts at 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{e}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} bounds of the values for the bath energies (absolute value)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyb}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} average and deviation of the normal hybridization parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shyb}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} average and deviation of the anomalous hybridization parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pr}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} prints the starting values if True

\end{itemize}

\item[{Return str}] \leavevmode
\sphinxAtStartPar
initialization string

\end{description}\end{quote}

\end{fulllineitems}

\index{starting\_values\_PH() (pyqcm.cdmft.general\_bath method)@\spxentry{starting\_values\_PH()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.starting_values_PH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{starting\_values\_PH}}}{\emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{e}\DUrole{o}{=}\DUrole{default_value}{(1, 0.5)}}, \emph{\DUrole{n}{hyb}\DUrole{o}{=}\DUrole{default_value}{(0.5, 0.2)}}, \emph{\DUrole{n}{phi}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{pr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
returns an initialization string for the bath parameters, in the particle\sphinxhyphen{}hole symmetric case.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} cluster label

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{e}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} range of bath energies

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyb}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} range of hybridizations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} PH phases of the cluster sites proper

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pr}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, prints info

\end{itemize}

\item[{Return str}] \leavevmode
\sphinxAtStartPar
initialization string

\end{description}\end{quote}

\end{fulllineitems}

\index{varia() (pyqcm.cdmft.general\_bath method)@\spxentry{varia()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.varia}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{varia}}}{\emph{\DUrole{n}{H}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{E}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_down}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
creates a dict of variational parameters to values taken from the hybridization matrix H and the energies E, for cluster c
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{H}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} matrix of hybridization values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{E}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} array of energy values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_down}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True for the spin\sphinxhyphen{}down values

\end{itemize}

\item[{Return \{str,float\}}] \leavevmode
\sphinxAtStartPar
dict of variational parameters to values

\end{description}\end{quote}

\end{fulllineitems}

\index{varia\_E() (pyqcm.cdmft.general\_bath method)@\spxentry{varia\_E()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.varia_E}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{varia\_E}}}{\emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\sphinxAtStartPar
returns a list of parameter names from the bath energies with the suffix appropriate for cluster c
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (starts at 1)

\item[{Return {[}str{]}}] \leavevmode
\sphinxAtStartPar
list of parameter names from the bath energies with the suffix appropriate for cluster c

\end{description}\end{quote}

\end{fulllineitems}

\index{varia\_H() (pyqcm.cdmft.general\_bath method)@\spxentry{varia\_H()}\spxextra{pyqcm.cdmft.general\_bath method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cdmft:pyqcm.cdmft.general_bath.varia_H}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{varia\_H}}}{\emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\sphinxAtStartPar
returns a list of parameter names from the bath hybridization with the suffix appropriate for cluster c
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (starts at 1)

\item[{Return {[}str{]}}] \leavevmode
\sphinxAtStartPar
list of parameter names from the bath hybridization with the suffix appropriate for cluster c

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{The Variational Cluster Approximation}
\label{\detokenize{vca:the-variational-cluster-approximation}}\label{\detokenize{vca::doc}}
\sphinxAtStartPar
This submodule provides functions that implements the Variational Cluster Approximation (VCA)


\section{List of functions}
\label{\detokenize{vca:module-pyqcm.vca}}\label{\detokenize{vca:list-of-functions}}\index{module@\spxentry{module}!pyqcm.vca@\spxentry{pyqcm.vca}}\index{pyqcm.vca@\spxentry{pyqcm.vca}!module@\spxentry{module}}\index{plot\_GS\_energy() (in module pyqcm.vca)@\spxentry{plot\_GS\_energy()}\spxextra{in module pyqcm.vca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vca:pyqcm.vca.plot_GS_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.vca.}}\sphinxbfcode{\sphinxupquote{plot\_GS\_energy}}}{\emph{\DUrole{n}{param}}, \emph{\DUrole{n}{prm}}, \emph{\DUrole{n}{clus}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plt\_ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Draws a plot of the ground state energy as a function of a parameter param taken from the list \sphinxtitleref{prm}. The results are going to be appended to ‘GS.tsv’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the parameter (independent variable)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prm}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of values of the parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} label of the cluster (starts at 0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} if not None, saves the plot in a file with that name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plt\_ax}} \textendash{} optional matplotlib axis set, to be passed when one wants to collect a subplot of a larger set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} keyword arguments passed to the matplotlib ‘plot’ function

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_sef() (in module pyqcm.vca)@\spxentry{plot\_sef()}\spxextra{in module pyqcm.vca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vca:pyqcm.vca.plot_sef}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.vca.}}\sphinxbfcode{\sphinxupquote{plot\_sef}}}{\emph{\DUrole{n}{param}}, \emph{\DUrole{n}{prm}}, \emph{\DUrole{n}{accur\_SEF}\DUrole{o}{=}\DUrole{default_value}{0.0001}}, \emph{\DUrole{n}{hartree}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Draws a plot of the Potthoff functional as a function of a parameter param taken from the list prm. The results are going to be appended to ‘sef.tsv’
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the parameter (independent variable)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prm}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of values of the parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur\_SEF}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} precision of the computation of the self\sphinxhyphen{}energy functional

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Hartree approximation couplings (see pyqcm/hartree.py)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, the plot is shown on the screen.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{transition\_line() (in module pyqcm.vca)@\spxentry{transition\_line()}\spxextra{in module pyqcm.vca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vca:pyqcm.vca.transition_line}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.vca.}}\sphinxbfcode{\sphinxupquote{transition\_line}}}{\emph{\DUrole{n}{varia}}, \emph{\DUrole{n}{P1}}, \emph{\DUrole{n}{P1\_range}}, \emph{\DUrole{n}{P2}}, \emph{\DUrole{n}{P2\_range}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{n}{verb}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Builds the second\sphinxhyphen{}order transition line as a function of a control parameter P1. The results are written in the file \sphinxtitleref{transition.tsv}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} variational parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P1}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} control parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P1\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} an array of values of P1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P2}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} dependent parameter

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P2\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} 2\sphinxhyphen{}uple of values of P2 that bracket the transition

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verb}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} If True, prints progress

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} at each step, the new bracket for P2 will be P2c +/\sphinxhyphen{} delta, P2c being the previous critical value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{vca() (in module pyqcm.vca)@\spxentry{vca()}\spxextra{in module pyqcm.vca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vca:pyqcm.vca.vca}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.vca.}}\sphinxbfcode{\sphinxupquote{vca}}}{\emph{\DUrole{n}{var2sef}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{start}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{steps}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{accur\_grad}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{max\_iter}\DUrole{o}{=}\DUrole{default_value}{30}}, \emph{\DUrole{n}{max\_iter\_diff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{NR}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{hartree}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{hartree\_self\_consistent}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Performs a VCA with the QN or NR method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var2sef}} \textendash{} function that converts variational parameters to model parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{names}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} names of the variational parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} starting values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{steps}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} initial steps

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} accuracy of parameters (also step for 2nd derivatives)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} maximum values that are tolerated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur\_grad}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} max value of gradient for convergence

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_iter}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} maximum number of iterations in the procedure

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_iter\_diff}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} optional maximum value of the maximum step in the quasi\sphinxhyphen{}Newton method

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NR}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True if the Newton\sphinxhyphen{}Raphson method is used, False if the quasi\sphinxhyphen{}Newton method is used

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Hartree approximation couplings (see pyqcm/hartree.py)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree\_self\_consistent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True if the Hartree approximation is treated in the self\sphinxhyphen{}consistent, rather than variational, way.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{vca\_min() (in module pyqcm.vca)@\spxentry{vca\_min()}\spxextra{in module pyqcm.vca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vca:pyqcm.vca.vca_min}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.vca.}}\sphinxbfcode{\sphinxupquote{vca\_min}}}{\emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{start}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{steps}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.0001}}, \emph{\DUrole{n}{ftol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}08}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Nelder\sphinxhyphen{}Mead\textquotesingle{}}}, \emph{\DUrole{n}{hartree}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Performs the VCA assuming that the solution is a minimum of the Potthoff functional
Uses minimization routines from scipy.optimize.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{names}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} names of the variational parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} starting values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{steps}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} initial steps (relevant to some minimization methods)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} accuracy of parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ftol}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} convergence criterion for the value of the SEF

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} minimization method used in scipy.optimize.minimize()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hartree}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Hartree approximation couplings (see pyqcm/hartree.py)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Hartree approximation and counterterms}
\label{\detokenize{utilities:hartree-approximation-and-counterterms}}\label{\detokenize{utilities::doc}}

\section{The Hartree approximation}
\label{\detokenize{utilities:the-hartree-approximation}}
\sphinxAtStartPar
Extended interactions require an extension of quantum cluster methods: inter\sphinxhyphen{}cluster interactions have to be cut off and replaced by a mean field, in the Hartree approximation.
An extended interaction on the cluster is then reduced to
\begin{equation*}
\begin{split}\sum_{(ij)}V^c_{ij}n_i n_j +
\sum_{(ij)}V^m_{ij}\left(n_i \langle n_j\rangle + n_j \langle n_i\rangle - \langle n_i\rangle\langle n_j\rangle \right)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(V_m\) stands for the terms of \(V_{ij}\) which need to be treated in the Hartree approximation, and \(V^c\) those that do not need to be. \((ij)\) stands for a pair of sites (\(i\ne j\)).

\sphinxAtStartPar
Since \(V_m\) is real symmetric, the mean\sphinxhyphen{}field Hamiltonian may be recast into
\begin{equation*}
\begin{split}H_m = \sum_{ij}V^m_{ij}\left(n_i \langle n_j\rangle - \frac12\langle n_i\rangle\langle n_j\rangle \right)\end{split}
\end{equation*}
\sphinxAtStartPar
where now the sum is over independent values of \(i\) and \(j\).
\(V^m\) can be diagonalized by an orthogonal transformation \(L\): \(V^m = L\Lambda \tilde L\).
One then defines eigenoperators \(O_a = L_{aj}n_j\) such that
\begin{equation*}
\begin{split}H_m = \sum_a \lambda_a\left\{O_a \langle O_a\rangle - \frac12 \langle O_a\rangle^2\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
Now, let us consider the mean values \(\langle O_a\rangle\) as adjustable variational (or mean\sphinxhyphen{}field) parameters.
Then, in terms of the coefficients \(h_a=\lambda_a\langle O_a\rangle\) of the operator \(O_a\), the mean\sphinxhyphen{}field Hamiltonian takes the following form:
\begin{equation*}
\begin{split}H_m = \sum_a \left\{ h_a O_a - \frac{h_a^2}{2\lambda_a} \right\}\end{split}
\end{equation*}
\sphinxAtStartPar
The variation of parameter \(h_a\) the yields
\begin{equation*}
\begin{split}\langle O_a\rangle = \frac{h_a}{\lambda_a} \rightarrow h_a=\lambda_a\langle O_a\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
The Hartree procedure consists in starting with trial values of \(_a\) and iteratively performing the above assignation until convergence.


\section{List of functions}
\label{\detokenize{utilities:list-of-functions}}\index{hartree (class in pyqcm.hartree)@\spxentry{hartree}\spxextra{class in pyqcm.hartree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.hartree.}}\sphinxbfcode{\sphinxupquote{hartree}}}{\emph{\DUrole{n}{Vm}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{eig}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.0001}}, \emph{\DUrole{n}{accur\_rel}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{lattice}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
This class contains the elements needed to perform the Hartree approximation for the inter\sphinxhyphen{}cluster components of an
extended interaction. The basic self\sphinxhyphen{}consistency relation is
\begin{equation*}
\begin{split}v_m = ve\langle V_m\rangle    \end{split}
\end{equation*}
\sphinxAtStartPar
where \sphinxstyleemphasis{v} is the coefficient of the operator \sphinxstyleemphasis{V} and \(v_m\) that of the operator \(V_m\), and \sphinxstyleemphasis{e} is an eigenvalue specific to the cluster shape and the interaction. \(\langle V_m\rangle\) is the average of the operator \(V_m\), taken
as a lattice of as a cluster average.
\begin{description}
\item[{attributes:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Vm (str) : mean\sphinxhyphen{}field operator

\item {} 
\sphinxAtStartPar
V (str) : extended interaction

\item {} 
\sphinxAtStartPar
eig (float) : eigenvalue \sphinxstyleemphasis{e} of the mean\sphinxhyphen{}field operator in the self\sphinxhyphen{}consistency relation

\item {} 
\sphinxAtStartPar
lattice (boolean) : True if lattice averages are used

\item {} 
\sphinxAtStartPar
diff : difference between successive values of \(v_m\)

\item {} 
\sphinxAtStartPar
ave : averasge of the operator \(V_m\)

\item {} 
\sphinxAtStartPar
accur : desired accuracy

\end{itemize}

\end{description}
\index{\_\_init\_\_() (pyqcm.hartree.hartree method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.hartree.hartree method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{Vm}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{eig}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.0001}}, \emph{\DUrole{n}{accur\_rel}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{lattice}\DUrole{o}{=}\DUrole{default_value}{False}}}{}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Vm}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the mean\sphinxhyphen{}field operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{V}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the interaction operator

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eig}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} eigenvalue

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} required accuracy of the self\sphinxhyphen{}consistent procedure

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur\_rel}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} required relative accuracy of the self\sphinxhyphen{}consistent procedure

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lattice}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, the lattice average is used, otherwise the cluster average

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{converged() (pyqcm.hartree.hartree method)@\spxentry{converged()}\spxextra{pyqcm.hartree.hartree method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree.converged}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{converged}}}{}{}
\sphinxAtStartPar
Tests whether the mean\sphinxhyphen{}field procedure has converged
\begin{quote}\begin{description}
\item[{Return boolean}] \leavevmode
\sphinxAtStartPar
True if the mean\sphinxhyphen{}field procedure has converged

\end{description}\end{quote}

\end{fulllineitems}

\index{omega() (pyqcm.hartree.hartree method)@\spxentry{omega()}\spxextra{pyqcm.hartree.hartree method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree.omega}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{omega}}}{}{}
\sphinxAtStartPar
returns the constant contribution, added to the Potthoff functional

\end{fulllineitems}

\index{omega\_var() (pyqcm.hartree.hartree method)@\spxentry{omega\_var()}\spxextra{pyqcm.hartree.hartree method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree.omega_var}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{omega\_var}}}{}{}
\sphinxAtStartPar
returns the constant contribution, added to the Potthoff functional

\end{fulllineitems}

\index{update() (pyqcm.hartree.hartree method)@\spxentry{update()}\spxextra{pyqcm.hartree.hartree method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.hartree.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{pr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Updates the value of the mean\sphinxhyphen{}field operator based on its average
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pr}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, progress is printed on the screen

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Counterterms}
\label{\detokenize{utilities:counterterms}}\index{counterterm (class in pyqcm.hartree)@\spxentry{counterterm}\spxextra{class in pyqcm.hartree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.counterterm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.hartree.}}\sphinxbfcode{\sphinxupquote{counterterm}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{clus}}, \emph{\DUrole{n}{S}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.0001}}}{}
\sphinxAtStartPar
That class contains information about operators that are added to the cluster 
Hamiltonian in order to make their average vanish. The coefficient \sphinxstyleemphasis{v} of the operator \sphinxstyleemphasis{V}
is adjusted so that \(\langle V\rangle=0\). The coefficient is updated using the 
relation
\begin{equation*}
\begin{split}\langle O_1\rangle-\langle O_2\rangle = S (v_1-v_2)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(v_{1,2}\) are two values of the coefficient of the operator used in succession,
\(\langle v_{1,2}\rangle\) are the corresponding averages and \sphinxstyleemphasis{S} is the (varying) slope.
\begin{description}
\item[{attributes:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
name (str) : name of the countererm operator

\item {} 
\sphinxAtStartPar
fullname (str) : name, including the cluster label

\item {} 
\sphinxAtStartPar
clus (int) : label of the cluster

\item {} 
\sphinxAtStartPar
S (float) : slope

\item {} 
\sphinxAtStartPar
accur (float) : accuracy to which the average must vanish.

\item {} 
\sphinxAtStartPar
v (float) : value of the coefficient of the operator

\item {} 
\sphinxAtStartPar
v0 (float) : previous value of the coefficient of the operator (previous iteration)

\end{itemize}

\end{description}
\index{\_\_init\_\_() (pyqcm.hartree.counterterm method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.hartree.counterterm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.counterterm.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{clus}}, \emph{\DUrole{n}{S}}, \emph{\DUrole{n}{accur}\DUrole{o}{=}\DUrole{default_value}{0.0001}}}{}
\sphinxAtStartPar
Constructor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the counterterm (previously defined in the model)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clus}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} cluster label to which it is applied

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} initial value of the slope

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{accur}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} accuracy

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{converged() (pyqcm.hartree.counterterm method)@\spxentry{converged()}\spxextra{pyqcm.hartree.counterterm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.counterterm.converged}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{converged}}}{}{}
\sphinxAtStartPar
Performs a convergence test
\begin{quote}\begin{description}
\item[{Return boolean}] \leavevmode
\sphinxAtStartPar
True if converged

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (pyqcm.hartree.counterterm method)@\spxentry{update()}\spxextra{pyqcm.hartree.counterterm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.hartree.counterterm.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{first}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
updates the value of the operator given its averaged
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} True if this is the first time it is called for a given iterative sequence

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Looping utilities}
\label{\detokenize{utilities:module-pyqcm.loop}}\label{\detokenize{utilities:looping-utilities}}\index{module@\spxentry{module}!pyqcm.loop@\spxentry{pyqcm.loop}}\index{pyqcm.loop@\spxentry{pyqcm.loop}!module@\spxentry{module}}\index{Hartree() (in module pyqcm.loop)@\spxentry{Hartree()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.Hartree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{Hartree}}}{\emph{\DUrole{n}{F}}, \emph{\DUrole{n}{couplings}}, \emph{\DUrole{n}{maxiter}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{eps\_algo}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Performs the Hartree approximation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{F}} \textendash{} task to perform wihtin the loop

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{couplings}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{class hartree}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of Hartree couplings (or single coupling)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxiter}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} maximum number of Hartree iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eps\_algo}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of elements in the epsilon algorithm convergence accelerator = 2*eps\_algo + 1 (0 = no acceleration)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{controlled\_loop() (in module pyqcm.loop)@\spxentry{controlled\_loop()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.controlled_loop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{controlled\_loop}}}{\emph{\DUrole{n}{func}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{varia}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{loop\_param}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{loop\_range}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{control\_func}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{adjust}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{predict}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Performs a controlled loop for VCA or CDMFT with a predictor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{func}} \textendash{} function called at each step of the loop

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} names of the variational parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loop\_param}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the parameter looped over

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loop\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} range of the loop (min, max, step)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{control\_func}} \textendash{} (optional) name of the function that controls the loop (returns boolean)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{adjust}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, adjusts the steps depending on control or status of convergence

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predict}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, uses a linear or quadratic predictor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fade() (in module pyqcm.loop)@\spxentry{fade()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.fade}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{fade}}}{\emph{\DUrole{n}{F}}, \emph{\DUrole{n}{p1}}, \emph{\DUrole{n}{p2}}, \emph{\DUrole{n}{n}}}{}
\sphinxAtStartPar
fades the model between two sets of parameters, in n steps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{F}} \textendash{} task to perform wihtin the loop

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p1}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} first set of parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p2}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} second set of parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} number of steps

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fixed\_density\_loop() (in module pyqcm.loop)@\spxentry{fixed\_density\_loop()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.fixed_density_loop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{fixed\_density\_loop}}}{\emph{\DUrole{n}{mu}}, \emph{\DUrole{n}{target\_n}}, \emph{\DUrole{n}{kappa}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{maxdmu}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{func}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{loop\_param}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{loop\_values}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{var\_param}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{dens\_tol}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{dir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{measure}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cluster\_density}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Performs a loop while trying to keep a fixed density
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} initial value of mu

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_n}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} desired value of the density

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kappa}} \textendash{} initial guess of the compressibility

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxdmu}} \textendash{} maximum change in mu at each step (absolute value)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{func}} \textendash{} function called at each step of the loop. No required argument. returns None.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loop\_param}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the parameter looped over

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loop\_values}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} an array of values of loop\_param

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var\_param}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} array of variational parameters (names) to be predicted

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dens\_tol}} \textendash{} tolerance on the value of the density

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dir}} \textendash{} directory of calling script

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measure}} \textendash{} name of function to be called when the desired density is reached

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster\_density}} \textendash{} if True, uses the cluster density instead of the lattice density

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{linear\_loop() (in module pyqcm.loop)@\spxentry{linear\_loop()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.linear_loop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{linear\_loop}}}{\emph{\DUrole{n}{N}}, \emph{\DUrole{n}{func}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{varia}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{params}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{predict}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Performs a controlled loop for VCA or CDMFT with a predictor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N}} \textendash{} number of intervals within the loop

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{func}} \textendash{} function called at each step of the loop

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varia}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} names of the variational parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{str:}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{\}}}) \textendash{} dict of parameters to vary with initial and final values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predict}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} if True, uses a linear or quadratic predictor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{loop\_from\_file() (in module pyqcm.loop)@\spxentry{loop\_from\_file()}\spxextra{in module pyqcm.loop}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.loop.loop_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.loop.}}\sphinxbfcode{\sphinxupquote{loop\_from\_file}}}{\emph{\DUrole{n}{func}}, \emph{\DUrole{n}{file}}}{}
\sphinxAtStartPar
Performs a task over a set of instances defined in a file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{func}} \textendash{} function (task) to perform

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the data file specifying the solutions, in the same tab\sphinxhyphen{}separated format usually used to write solutions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Other utilities}
\label{\detokenize{utilities:other-utilities}}

\section{Profile of expectation values}
\label{\detokenize{utilities:module-pyqcm.profile}}\label{\detokenize{utilities:profile-of-expectation-values}}\index{module@\spxentry{module}!pyqcm.profile@\spxentry{pyqcm.profile}}\index{pyqcm.profile@\spxentry{pyqcm.profile}!module@\spxentry{module}}\index{plot\_profile() (in module pyqcm.profile)@\spxentry{plot\_profile()}\spxextra{in module pyqcm.profile}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.profile.plot_profile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyqcm.profile.}}\sphinxbfcode{\sphinxupquote{plot\_profile}}}{\emph{\DUrole{n}{n\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{bond\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{current\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{spin\_angle}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{bond\_spin\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{singlet\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{triplet\_scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{layer}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Produces a figure of various local quantities on the repeated unit, from averages computed in the ground state wavefunction
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the density

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bond\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the bond charge density

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the currents on the bonds

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the spins on the sites

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{spin\_angle}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} angle at which to draw the spins, from their nominal direction

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bond\_spin\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the spins on the bonds

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{singlet\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the singlet pairing amplitudes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{triplet\_scale}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} scale factor applied to the triplet pairing amplitudes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the output file, if not None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} layer number (z coordinate)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Defining models for slabs}
\label{\detokenize{utilities:defining-models-for-slabs}}\index{slab (class in pyqcm.slab)@\spxentry{slab}\spxextra{class in pyqcm.slab}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.slab.slab}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pyqcm.slab.}}\sphinxbfcode{\sphinxupquote{slab}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{nlayer}}, \emph{\DUrole{n}{cluster}}, \emph{\DUrole{n}{sites}}, \emph{\DUrole{n}{superlattice}}, \emph{\DUrole{n}{lattice}}, \emph{\DUrole{n}{thickness}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Helper class to define multi\sphinxhyphen{}layer systems, typically layers of planes.
The fundamental unit is a 2D model that is repeated in the z direction
\index{\_\_init\_\_() (pyqcm.slab.slab method)@\spxentry{\_\_init\_\_()}\spxextra{pyqcm.slab.slab method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.slab.slab.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{nlayer}}, \emph{\DUrole{n}{cluster}}, \emph{\DUrole{n}{sites}}, \emph{\DUrole{n}{superlattice}}, \emph{\DUrole{n}{lattice}}, \emph{\DUrole{n}{thickness}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Constructor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the 2D model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nlayer}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} total number of layers in the slab

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cluster}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} name of the cluster model assembled (limited to one cluster)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sites}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of sites in each layer

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{superlattice}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} superlattice vectors in 2D

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lattice}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} lattice vectors in 2D

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thickness}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of inequivalent layers (\textless{}= nlayer/2). If None, all layers are different

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{hopping\_operator() (pyqcm.slab.slab method)@\spxentry{hopping\_operator()}\spxextra{pyqcm.slab.slab method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.slab.slab.hopping_operator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hopping\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{link}}, \emph{\DUrole{n}{amplitude}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines a hopping operator
Same arguments as the pyqcm.hopping\_operator() function

\end{fulllineitems}

\index{interaction\_operator() (pyqcm.slab.slab method)@\spxentry{interaction\_operator()}\spxextra{pyqcm.slab.slab method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:pyqcm.slab.slab.interaction_operator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interaction\_operator}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Defines an interaction operator
Same arguments as the pyqcm.interaction\_operator() function

\end{fulllineitems}


\end{fulllineitems}



\chapter{Summary of options}
\label{\detokenize{options:summary-of-options}}\label{\detokenize{options::doc}}
\sphinxAtStartPar
The behavior of \sphinxtitleref{qcm} can be controlled by many global parameters that can be set via a call to \sphinxcode{\sphinxupquote{qcm.set\_global\_parameter()}}.
There are four kinds of global parameter, depending on the type of variable involved:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Boolean parameter. They are all false by default. Calling \sphinxcode{\sphinxupquote{qcm.set\_global\_parameter(name)}} with the name of the parameter sets that parameter to True.

\item {} 
\sphinxAtStartPar
integer\sphinxhyphen{}valued parameter. Calling \sphinxcode{\sphinxupquote{qcm.set\_global\_parameter(name, val)}} with the name of the parameter sets that parameter’s value to \sphinxcode{\sphinxupquote{val}}.

\item {} 
\sphinxAtStartPar
real\sphinxhyphen{}valued parameter. Same calling prototype as above.

\item {} 
\sphinxAtStartPar
string\sphinxhyphen{}valued parameter. Same calling prototype as above.

\end{enumerate}

\sphinxAtStartPar
The following tables list the different global parameters, their default value and a short description.


\section{Boolean options}
\label{\detokenize{options:boolean-options}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{15}{75}|\X{10}{75}|\X{50}{75}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
description
\\
\hline
\sphinxAtStartPar
verb\_Hilbert
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
prints progress information on bases and operators in the Hilbert space
\\
\hline
\sphinxAtStartPar
verb\_ED
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
prints ED information and progress
\\
\hline
\sphinxAtStartPar
verb\_integrals
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
prints information and progress about integrals
\\
\hline
\sphinxAtStartPar
CSR\_sym\_store
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
stores CSR matrices fully for openMP application
\\
\hline
\sphinxAtStartPar
strip\_anomalous\_self
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
sets to zero the anomalous part of the self\sphinxhyphen{}energy
\\
\hline
\sphinxAtStartPar
print\_Hamiltonian
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Prints the Hamiltonian on the screen, if small enough
\\
\hline
\sphinxAtStartPar
SEF\_calc
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Calculates the Self\sphinxhyphen{}energy functional, even when not performing VCA
\\
\hline
\sphinxAtStartPar
periodized\_averages
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
computes lattice averages using the periodized Green function
\\
\hline
\sphinxAtStartPar
continued\_fraction
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Uses the continued fraction solver for the Green function instead of the band Lanczos method
\\
\hline
\sphinxAtStartPar
dual\_basis
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
uses the dual basis for wavevector computations
\\
\hline
\sphinxAtStartPar
nosym
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
does not take cluster symmetries into account
\\
\hline
\sphinxAtStartPar
modified\_Lanczos
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Uses the modified Lanczos method for the ground state instead of the usual Lanczos method
\\
\hline
\sphinxAtStartPar
periodic
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
considers the cluster(s) as periodic
\\
\hline
\sphinxAtStartPar
zero\_dim
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
sets the spatial dimension to zero, on any model
\\
\hline
\sphinxAtStartPar
print\_all
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
prints dependent parameters as well
\\
\hline
\sphinxAtStartPar
check\_lanczos\_residual
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
checks the Lanczos residual at the end of the eigenvector computation
\\
\hline
\sphinxAtStartPar
no\_degenerate\_BL
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
forbids band lanczos to proceed when the eigenstates have degenerate energies
\\
\hline
\sphinxAtStartPar
potential\_energy
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Calculates the potential energy with Tr(Sigma*G) when computing averages
\\
\hline
\sphinxAtStartPar
one\_body\_solution
&
\sphinxAtStartPar
false
&
\sphinxAtStartPar
Only solves the one\sphinxhyphen{}body part of the problem, for the Green function
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Integer\sphinxhyphen{}valued options}
\label{\detokenize{options:integer-valued-options}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{15}{75}|\X{10}{75}|\X{50}{75}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
description
\\
\hline
\sphinxAtStartPar
max\_iter\_lanczos
&
\sphinxAtStartPar
600
&
\sphinxAtStartPar
Maximum number of iterations in the Lanczos procedure
\\
\hline
\sphinxAtStartPar
max\_iter\_QN
&
\sphinxAtStartPar
60
&
\sphinxAtStartPar
maximum number of iterations in the quasi\sphinxhyphen{}Newton method
\\
\hline
\sphinxAtStartPar
cuba3D\_mineval
&
\sphinxAtStartPar
16000
&
\sphinxAtStartPar
minimum number of integrand evaluations in CUBA (3D)
\\
\hline
\sphinxAtStartPar
seed
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
seed of the random number generator
\\
\hline
\sphinxAtStartPar
kgrid\_side
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
number of wavevectors on the side in a fixed wavevector grid
\\
\hline
\sphinxAtStartPar
print\_precision
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
precision of printed output
\\
\hline
\sphinxAtStartPar
cuba2D\_mineval
&
\sphinxAtStartPar
1024
&
\sphinxAtStartPar
minimum number of integrand evaluations in CUBA (2D)
\\
\hline
\sphinxAtStartPar
dim\_max\_print
&
\sphinxAtStartPar
64
&
\sphinxAtStartPar
Maximum dimension for printing vectors and matrices
\\
\hline
\sphinxAtStartPar
max\_iter\_CF
&
\sphinxAtStartPar
400
&
\sphinxAtStartPar
Maximum number of iterations in the continuous fraction Lanczos procedure
\\
\hline
\sphinxAtStartPar
GK\_min\_regions
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
minimum number of regions in the Gauss\sphinxhyphen{}Kronrod method
\\
\hline
\sphinxAtStartPar
Davidson\_states
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Number of states requested in the Davidson\sphinxhyphen{}Liu algorithm
\\
\hline
\sphinxAtStartPar
max\_dim\_full
&
\sphinxAtStartPar
256
&
\sphinxAtStartPar
Maximum dimension for using full diagonalization
\\
\hline
\sphinxAtStartPar
max\_iter\_BL
&
\sphinxAtStartPar
600
&
\sphinxAtStartPar
Maximum number of iterations in the band Lanczos procedure
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Real\sphinxhyphen{}valued options}
\label{\detokenize{options:real-valued-options}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{15}{75}|\X{10}{75}|\X{50}{75}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
description
\\
\hline
\sphinxAtStartPar
Qmatrix\_vtol
&
\sphinxAtStartPar
1e\sphinxhyphen{}10
&
\sphinxAtStartPar
minimum value of a Qmatrix contribution
\\
\hline
\sphinxAtStartPar
Qmatrix\_wtol
&
\sphinxAtStartPar
1e\sphinxhyphen{}05
&
\sphinxAtStartPar
maximum difference in frequencies in Q\sphinxhyphen{}matrix
\\
\hline
\sphinxAtStartPar
band\_lanczos\_minimum\_gap
&
\sphinxAtStartPar
1e\sphinxhyphen{}05
&
\sphinxAtStartPar
gap between the lowest two states in BL below which the method fails
\\
\hline
\sphinxAtStartPar
accur\_Q\_matrix
&
\sphinxAtStartPar
1e\sphinxhyphen{}05
&
\sphinxAtStartPar
tolerance in the normalization of the Q matrix
\\
\hline
\sphinxAtStartPar
minimum\_weight
&
\sphinxAtStartPar
0.01
&
\sphinxAtStartPar
minimum weight in the density matrix
\\
\hline
\sphinxAtStartPar
cutoff\_scale
&
\sphinxAtStartPar
1e+12
&
\sphinxAtStartPar
high\sphinxhyphen{}frequency cutoff in integrals
\\
\hline
\sphinxAtStartPar
large\_scale
&
\sphinxAtStartPar
20
&
\sphinxAtStartPar
high\sphinxhyphen{}frequency region for imaginary frequency axis integrals
\\
\hline
\sphinxAtStartPar
eta
&
\sphinxAtStartPar
0.0001
&
\sphinxAtStartPar
value of the imaginary part of the frequency in Chern number/Berry phase computations
\\
\hline
\sphinxAtStartPar
temperature
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Temperature of the system.
\\
\hline
\sphinxAtStartPar
accur\_OP
&
\sphinxAtStartPar
0.0001
&
\sphinxAtStartPar
accuracy of lattice averages
\\
\hline
\sphinxAtStartPar
small\_scale
&
\sphinxAtStartPar
0.5
&
\sphinxAtStartPar
low\sphinxhyphen{}frequency region for imaginary frequency axis integrals
\\
\hline
\sphinxAtStartPar
accur\_SEF
&
\sphinxAtStartPar
5e\sphinxhyphen{}08
&
\sphinxAtStartPar
Accuracy of the Potthoff functional
\\
\hline
\sphinxAtStartPar
accur\_continued\_fraction
&
\sphinxAtStartPar
0.01
&
\sphinxAtStartPar
value of beta below which the simple Lanczod process stops
\\
\hline
\sphinxAtStartPar
accur\_Davidson
&
\sphinxAtStartPar
1e\sphinxhyphen{}05
&
\sphinxAtStartPar
maximum norm of residuals in the Davidson\sphinxhyphen{}Liu algorithm
\\
\hline
\sphinxAtStartPar
accur\_lanczos
&
\sphinxAtStartPar
1e\sphinxhyphen{}12
&
\sphinxAtStartPar
tolerance of the Ritz residual estimate in the Lanczos method
\\
\hline
\sphinxAtStartPar
accur\_band\_lanczos
&
\sphinxAtStartPar
1e\sphinxhyphen{}12
&
\sphinxAtStartPar
energy difference tolerance for stopping the BL process
\\
\hline
\sphinxAtStartPar
accur\_deflation
&
\sphinxAtStartPar
1e\sphinxhyphen{}07
&
\sphinxAtStartPar
norm below which a vector is deflated in the Band Lanczos method
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Char\sphinxhyphen{}valued options}
\label{\detokenize{options:char-valued-options}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{15}{75}|\X{10}{75}|\X{50}{75}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
description
\\
\hline
\sphinxAtStartPar
Hamiltonian\_format
&
\sphinxAtStartPar
S
&
\sphinxAtStartPar
Desired Hamiltonian format: S (CSR matrix), O (individual operators), F (factorized), N (none = on the fly)
\\
\hline
\sphinxAtStartPar
periodization
&
\sphinxAtStartPar
G
&
\sphinxAtStartPar
periodization scheme: G, S, M, C or N (None)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{pyqcm}\sphinxstyleindexpageref{functions:\detokenize{module-pyqcm}}
\item\relax\sphinxstyleindexentry{pyqcm.berry}\sphinxstyleindexpageref{berry:\detokenize{module-pyqcm.berry}}
\item\relax\sphinxstyleindexentry{pyqcm.cdmft}\sphinxstyleindexpageref{cdmft:\detokenize{module-pyqcm.cdmft}}
\item\relax\sphinxstyleindexentry{pyqcm.loop}\sphinxstyleindexpageref{utilities:\detokenize{module-pyqcm.loop}}
\item\relax\sphinxstyleindexentry{pyqcm.profile}\sphinxstyleindexpageref{utilities:\detokenize{module-pyqcm.profile}}
\item\relax\sphinxstyleindexentry{pyqcm.spectral}\sphinxstyleindexpageref{spectral:\detokenize{module-pyqcm.spectral}}
\item\relax\sphinxstyleindexentry{pyqcm.vca}\sphinxstyleindexpageref{vca:\detokenize{module-pyqcm.vca}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}